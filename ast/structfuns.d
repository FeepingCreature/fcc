module ast.structfuns;

import ast.fun, ast.nestfun, ast.base, ast.structure, ast.variable, ast.casting,
  ast.properties, ast.pointer, ast.dg, ast.namespace, tools.base: This,
  This_fn, rmSpace;

import ast.modules;
Object gotStructFunDef(ref string text, ParseCb cont, ParseCb rest) {
  /*auto rs = fastcast!(RelNamespace)~ namespace();
  if (!rs)
    throw new Exception(Format("Fail: namespace is "[], namespace(), ". "[]));*/
  auto rs = namespace().get!(RelNamespace);
  if (!rs)
    throw new Exception(Format("Fail: no relns beneath "[], namespace(), ". "[]));
  auto fun = fastalloc!(RelFunction)(rs);
  
  if (auto res = gotGenericFunDef(fun, cast(Namespace) null, true, text, cont, rest)) {
    auto tr = fastcast!(Tree) (res);
    auto he = namespace().get!(HandlesEmits);
    if (!he || !he.handledEmit(tr))
      current_module().addEntry(tr);
    return res;
  } else return null;
}
mixin DefaultParser!(gotStructFunDef, "struct_member.struct_fundef"[]);

import ast.vardecl, ast.assign;
class RelFunCall : FunCall, RelTransformable {
  Expr baseptr;
  this(Expr ex) {
    baseptr = ex;
  }
  mixin defaultIterate!(baseptr, params);
  Tree collapse() { return this; } // don't do the FunCall name replacers
  override RelFunCall dup() {
    auto res = fastalloc!(RelFunCall)(baseptr?baseptr.dup:null);
    res.fun = fun;
    res.params = params.dup;
    foreach (ref entry; params) entry = entry.dup;
    return res;
  }
  override Object transform(Expr base) {
    // if (baseptr) { logln("RelFunCall was pretransformed: "[], baseptr, "; new base would be ", base); fail; }
    // I AM REALLY REALLY NOT SURE ABOUT THIS
    // TODO: smother in asserts
    if (baseptr) return this;
    if (!base) fail;
    auto res = dup();
    res.baseptr = base;
    return res;
  }
  override void emitLLVM(LLVMFile lf) {
    if (!baseptr) {
      logln("Untransformed rel-funcall: "[], this);
      fail;
    }
    /*
      okay this bit of code is definitely more hacky than it looks
      (and it looks pretty hacky)
      I think it's related to how in structs, "this" is a reference, not a pointer.
      (and what a horrible mistake that turned out to be, TODO fix)
      so we need to take the refexpr to get it back to a pointer for the dg
    */
    if (auto lv = fastcast!(LValue)(baseptr)) {
      callDg(lf, fun.type.ret, params,
        fastalloc!(DgConstructExpr)(fun.getPointer(), fastalloc!(RefExpr)(lv)));
    } else {
      // allocate a temporary
      auto bt = baseptr.valueType();
      auto bts=typeToLLVM(bt);
      auto bp = alloca(lf, "1", bts);
      put(lf, "store ", bts, " ", save(lf, baseptr), ", ", bts, "* ", bp);
      callDg(lf, fun.type.ret, params,
        fastalloc!(DgConstructExpr)(fun.getPointer(), fastalloc!(LLVMValue)(bp, fastalloc!(Pointer)(bt))));
    }
  }
  override IType valueType() {
    return fun.type.ret;
  }
}

class RelExtensibleOverloadWrapper : OverloadSet, RelTransformable {
  this(string name, Function[] funs...) { super(name, funs); }
  override {
    Object transform(Expr ex) {
      foreach (ref fun; funs) {
        if (auto rt = fastcast!(RelTransformable) (fun))
          fun = fastcast!(Function) (rt.transform(ex));
      }
      return this;
    }
    Extensible extend(Extensible ex) {
      auto os = fastcast!(OverloadSet) (super.extend(ex));
      if (!os) fail;
      return fastalloc!(RelExtensibleOverloadWrapper)(os.name, os.funs);
    }
  }
}

class RelFunction : Function, RelTransformable, HasInfo {
  Expr baseptr; // unique per instance
  IType basetype; // for mangling purposes
  RelNamespace context;
  Expr bp_cache;
  bool autogenerated; // was generated by the compiler
  this() { }
  this(RelNamespace rn) {
    context = rn;
    basetype = fastcast!(IType)~ rn;
    assert(!!basetype);
  }
  Argument[] argcache_impl;
  override {
    RelFunction alloc() { return fastalloc!(RelFunction)(); }
    Expr getPointer() { return fastalloc!(FunSymbol)(this, fastcast!(hasRefType)(context).getRefType()); }
    bool isInternal() { return true; }
    Argument[] getParams(bool implicits) {
      if (argcache_impl && implicits) return argcache_impl;
      
      auto res = super.getParams(false);
      if (implicits) {
        // res ~= Argument(fastcast!(hasRefType)(context).getRefType(), "__base_ptr");
        res ~= Argument(voidp, "__base_ptr");
        res ~= Argument(voidp, tlsbase);
        argcache_impl = res;
      }
      return res;
    }
    RelFunction flatdup() {
      auto res = fastcast!(RelFunction) (super.flatdup());
      res.context = context;
      res.baseptr = baseptr?baseptr.dup:null;
      res.basetype = basetype;
      return res;
    }
    RelFunction dup() {
      auto res = fastcast!(RelFunction) (super.dup());
      res.context = context;
      res.baseptr = baseptr?baseptr.dup:null;
      res.basetype = basetype;
      return res;
    }
    Object transform(Expr base) {
      if (baseptr) {
        debug logln("WARN: RelFun was already transformed with ", baseptr, ", new ", base);
        // fail;
      }
      assert(!!fastcast!(RelNamespace) (basetype));
      auto res = flatdup();
      if (!base) fail;
      res.baseptr = base;
      return res;
    }
    Extensible extend(Extensible e2) {
      auto res = super.extend(e2);
      if (!res) return null;
      auto os = fastcast!(OverloadSet) (res);
      if (!os || fastcast!(RelTransformable) (res)) return res;
      return fastalloc!(RelExtensibleOverloadWrapper)(os.name, os.funs);
    }
    Extensible simplify() { return this; }
  }
  FunctionPointer typeAsFp() {
    auto res = new FunctionPointer(this);
    if (auto rnfb = fastcast!(RelNamespaceFixupBase) (context))
      res.args ~= Argument(rnfb.genCtxType(context));
    else
      res.args ~= Argument(fastalloc!(Pointer)(basetype));
    return res;
  }
  void iterate(void delegate(ref Iterable) dg, IterMode mode = IterMode.Lexical) {
    super.iterate(dg, mode);
    defaultIterate!(baseptr).iterate(dg, mode);
  }
  mixin defaultCollapse!();
  override {
    string mangleSelf() {
      return qformat(basetype.mangle(), "_", super.mangleSelf());
    }
    string getInfo() { return Format(name, " under "[], context); }
    string mangle(string name, IType type) {
      return mangleSelf() ~ (type?("_" ~ type.mangle()):""[])~"_"~name;
    }
    FunCall mkCall() {
      auto res = fastalloc!(RelFunCall)(baseptr);
      res.fun = this;
      return res;
    }
    import ast.aliasing;
    int fixup() {
      auto id = super.fixup();
      auto hrt = fastcast!(hasRefType) (context);
      if (!hrt)
        logln("bad context: "[], context, " is not reftype"[]);
      
      auto bp = fastcast!(Expr)(lookup("__base_ptr"));
      if (!bp) {
        logln("in ", this);
        logln("field = ", field);
        fail;
      }
      // auto bp = fastalloc!(Variable)((fastcast!(hasRefType) (context)).getRefType(), id++, "__base_ptr");
      // add(bp);
      
      if (fastcast!(Pointer)~ bp.valueType())
        add(fastalloc!(LValueAlias)(fastalloc!(DerefExpr)(bp), "this"[]));
      return id;
    }
    Object lookup(string name, bool local = false) {
      auto res = super.lookup(name, true);
      if (res) {
        if (name == "__base_ptr") {
          // :sigh: I'm pretty sure this has more casts than function calls.
          res = fastcast!(Object)(reinterpret_cast((fastcast!(hasRefType) (context)).getRefType(), fastcast!(Expr)(res)));
        }
        return res;
      }
      else if (local) return null;
      
      if (!bp_cache) {
        auto bp = fastcast!(Expr) (lookup("__base_ptr"[], true));
        if (bp) {
          // bp = fastcast!(Expr) (reinterpret_cast((fastcast!(hasRefType) (context)).getRefType(), bp));
          if (auto ptr = fastcast!(Pointer) (bp.valueType())) bp = fastalloc!(DerefExpr)(bp);
          bp_cache = bp;
        }
      }
      if (bp_cache) {
        if (auto res = context.lookupRel(name, bp_cache))
          return res;
      }
      
      return super.lookup(name, false);
    }
  }
}

class LazyThisExpr : Expr, RelTransformable {
  IType it;
  Expr val;
  this(IType it, Expr val = null) { this.it = it; this.val = val; }
  mixin defaultIterate!(val);
  mixin defaultCollapse!();
  override {
    LazyThisExpr dup() { return fastalloc!(LazyThisExpr)(it, val?val.dup:null); }
    IType valueType() { return it; }
    string toString() { return qformat("this ", it); }
    Object transform(Expr base) {
      auto res = dup;
      // if (val) fail;
      if (val) return this;
      auto lv = fastcast!(LValue)(base);
      if (!lv) {
        // logln("Base is not an lvalue in LTE transform: ", base);
        // logln("value: ", val);
        // fail;
        // TODO WARN This is DEFINITELY wrong and will break with any but the most trivial cases.
        lv = lvize(base);
      }
      res.val = reinterpret_cast(it, fastalloc!(RefExpr)(lv));
      return res;
    }
    void emitLLVM(LLVMFile lf) {
      if (!val) {
        throw new Exception(qformat(this, ": cannot emit: untransformed"));
      }
      val.emitLLVM(lf);
    }
  }
}

// &foo.fun, stolen from ast.nestfun
class StructFunRefExpr : mkDelegate {
  RelFunction fun;
  this(RelFunction fun) {
    this.fun = fun;
    // logln("base ptr is "[], fun.baseptr);
    if (!fun.baseptr) {
      fun = fastcast!(RelFunction)(fun.transform(fastalloc!(DerefExpr)(fastalloc!(LazyThisExpr)(fastalloc!(Pointer)(fun.basetype)))));
    }
    super(fun.getPointer(), fastalloc!(RefExpr)(fastcast!(CValue)~ fun.baseptr));
  }
  override typeof(this) dup() { return new typeof(this)(fun); }
  override string toString() {
    return Format("&"[], fun.baseptr, "."[], fun);
  }
  override IType valueType() {
    return fastalloc!(Delegate)(fun.type.ret, fun.type.params);
  }
}

Object gotStructfunRefExpr(ref string text, ParseCb cont, ParseCb rest) {
  if (text.startsWith("&")) return null; // a && b != a & &b
  string ident;
  RelFunction rf;
  auto propbackup = propcfg().withCall;
  propcfg().withCall = false;
  scope(exit) propcfg().withCall = propbackup;
  if (!rest(text, "tree.expr _tree.expr.bin"[], &rf))
    return null;
  
  return fastalloc!(StructFunRefExpr)(rf);
}
mixin DefaultParser!(gotStructfunRefExpr, "tree.expr.dg_struct_ref"[], "21010"[], "&"[]);

static this() {
  getOpCall = delegate Object(Object obj) {
    auto ex = fastcast!(Expr) (obj); if (!ex) return null;
    auto st = fastcast!(Structure) (resolveType(ex.valueType()));
    if (!st) return null;
    auto oc = st.lookupRel("opCall", ex);
    if (!oc) return null;
    return oc;
  };
}
