module std.parser;

import std.string;

context parser {
  string text;
  string delegate(string) stripOverride;
  void cleanup() {
    // strip, eat comments
    do {
      if (stripOverride) text = stripOverride text;
      else text = text.strip();
    } while (text.startsWith "/*") {
      text = text.between("*/", "");
    }
  }
  bool accept(string match) using scoped text {
    cleanup;
    if (auto rest = text.startsWith(match)) text = rest;
    else return false;
    commit;
    return true;
  }
  bool done() {
    cleanup;
    return !text.length;
  }
  string slice(string to) {
    cleanup;
    return .slice(&text, to);
  }
  string gotIdentifier() {
    cleanup;
    string eatAlpha() {
      if (!text.length) return null;
      string res;
      if ("a" <= text[0] <= "z" || "A" <= text[0] <= "Z") (res, text) = text[(0..1, 1..$)];
      return res;
    }
    char[auto~] res;
    while auto ch = eatAlpha() res ~= ch;
    return res[];
  }
  bool gotNumber(int* ip) {
    cleanup;
    bool eatDigit(int* ip) {
      alias i = *ip;
      if (!text.length) return false;
      if ("0" <= text[0] <= "9") {
        i = text[0] - "0";
        text = text[1..$];
        return true;
      }
      return false;
    }
    int res;
    bool mew;
    while eatDigit(&int d) { mew = true; res = res * 10 + d; }
    if (!mew) return false;
    *ip = res; return true;
  }
  int getNumber() {
    if (gotNumber &int i) return i;
    fail "could not parse number";
  }
  string gotString(string sep = "\"") {
    using scoped text {
      if (!accept sep) return null;
      int i;
      alias left = that[i..$];
      while (i < that.length) {
        if (left.startsWith sep) break;
        if (left[0] == "\\") i++;
        i++;
      } then return null; // eee
      auto res = that[0..i];
      that = left;
      assert accept sep;
      commit;
      return res;
    }
  }
}
