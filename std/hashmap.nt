module std.hashmap;

// FNV hash, compare http://isthe.com/chongo/tech/comp/fnv/#FNV-1a
alias FNV_prime = 16777619;
alias FNV_offset = 2166136261;
alias FNVStep = `
  i = i xor (%V);
  i = i * FNV_prime;
`;
template hashptr_fnv(PTR) {
  void hashptr_fnv(PTR ptr, int* ip) {
    pragma(fast);
    alias t = *ptr;
    alias T = type-of t;
    alias i = *ip;
    static if (types-equal (T, int)) {
      mixin FNVStep.replace("%V", "t");
      return;
      bool matched;
    }
    static if (types-equal (T, float) || types-equal (T, bool) || type-is pointer T) {
      mixin FNVStep.replace("%V", "*int*:&t");
      return;
      bool matched;
    }
    static if (!is-defined matched && (type-is tuple T || type-is vector T)) {
      static for (int i <- 0..t.length)
        .hashptr_fnv!type-of &t[i] (&t[i], ip);
      return;
      bool matched;
    }
    static if (!is-defined matched && type-is struct T) {
      static for (int i <- 0..t.tupleof.length) {
        alias entry = t.tupleof[i];
        .hashptr_fnv!type-of &entry (&entry, ip);
      }
      return;
      bool matched;
    }
    static if (!is-defined matched && types-equal (T, string)) {
      string str = t, rest;
      int last;
      if (str.length % 4 != 0) {
        auto marker = str.length - str.length % 4;
        (str, rest) = str[(0..marker, marker..$)];
        for auto ub <- ubyte[]:rest last = (last << 8) + ub;
      }
      for int v <- int[]:str mixin FNVStep.replace("%V", "v");
      mixin FNVStep.replace("%V", "last");
      return;
      bool matched;
    }
    // TODO interface Hashed { uint hash(); } or in Object
    static if (!is-defined matched && (type-is interface T || type-is class T)) {
      mixin FNVStep.replace("%V", "*int*:&t");
      return;
      bool matched;
    }
    static if (!is-defined matched) {
      pragma(fail, string-of T ~ ": how do I hash web?");
    }
  }
}

template hashptr(PTR) {
  int hashptr(PTR ptr) {
    int res = FNV_offset;
    hashptr_fnv!PTR(ptr, &res);
    return res;
  }
}

template eq(T) {
  bool eq(T* ap, bp) {
    alias a = *ap, b = *bp;
    static if (!is-defined matched && (type-is interface T || type-is class T)) {
      return a is b;
      bool matched;
    }
    static if (!is-defined matched) {
      return a == b;
    }
  }
}

enum SetState { NotSet, Set, Deleted }

template Hashmap(T) {
  alias Key = T[0], Value = T[1];
  alias α = 0.5;
  struct Hashmap {
    (Key key, Value value)[] backing;
    SetState[] isset;
    int length;
    float load() {
      pragma(fast);
      if (!backing.length) return 1;
      return length * 1f / backing.length;
    }
    void iterate(void delegate(Key, Value) dg) {
      iterate \(Key* kp, Value* vp) { dg(*kp, *vp); }
    }
    void iterate(void delegate(Key*, Value*) dg) {
      pragma(fast);
      for int i <- 0..backing.length if (isset[i] == SetState.Set) {
        alias entry = backing[i];
        dg (&entry[0], &entry[1]);
      }
    }
    void realloc(int newsize) {
      pragma(fast);
      type-of this newmap;
      newmap.backing = new type-of backing newsize;
      newmap.isset = new type-of isset newsize;
      iterate(\(Key* kp, Value* vp) newmap.insert(kp, vp););
      this = newmap;
    }
    void clear() {
      length = 0;
      for ref state <- isset state = SetState.NotSet;
    }
    Value* insert(Key k, Value v) { return insert(&k, &v); }
    Value* insert(Key* kp, Value* vp) {
      pragma(fast);
      alias k = Key:*kp, v = Value:*vp;
      do auto loadf = load();
      while (loadf > α) {
        auto newsize = backing.length * 2;
        if (!newsize) newsize = 16;
        realloc newsize;
      }
      auto pos = (hashptr &k) % backing.length;
      while (isset[pos] == SetState.Set && !eq!Key(&backing[pos][0], &k)) {
        if (++pos == backing.length) pos = 0;
      }
      backing[pos] = (k, v);
      if (isset[pos] != SetState.Set) {
        isset[pos] = SetState.Set;
        length ++;
      }
      return &backing[pos][1];
    }
    void remove(Key k) { return remove(&k); }
    void remove(Key* kp) {
      pragma(fast);
      if (!backing.length) return;
      alias k = Key:*kp;
      auto pos = (hashptr &k) % backing.length;
      while (isset[pos] != SetState.NotSet) {
        if (isset[pos] == SetState.Set && eq!Key(&backing[pos][0], &k)) {
          isset[pos] = SetState.Deleted;
          return;
        }
        if (++pos == backing.length) pos = 0;
      }
    }
    // if allocate is true, get returns a pointer to a fresh slot if not found
    Value* get(Key k, bool allocate = false) { return get (&k, allocate); }
    Value* get(Key* kp, bool allocate = false) {
      pragma(fast);
      alias k = *kp;
      if (!backing.length) {
        if (allocate) { 
          insert(kp, &Value nv);
          return get kp;
        } else return null;
      }
      auto pos = (hashptr &k) % backing.length;
      while (isset[pos] != SetState.NotSet) {
        if (isset[pos] == SetState.Set && eq!Key(&backing[pos][0], &k)) {
          return &backing[pos][1];
        }
        if (++pos == backing.length) pos = 0;
      }
      if (allocate) {
        insert(kp, &Value nv);
        return get kp;
      } else return null;
    }
  }
}
