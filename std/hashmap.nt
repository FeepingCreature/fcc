module std.hashmap;

// FNV hash, compare http://isthe.com/chongo/tech/comp/fnv/#FNV-1a
alias FNV_prime = 16777619;
alias FNV_offset = 2166136261;
alias FNVStep = `
  i = i xor (%V);
  i = i * FNV_prime;
`;
import std.string;
template hashptr_fnv(PTR) {
  void hashptr_fnv(PTR ptr, int* ip) {
    pragma(fast);
    alias t = *ptr;
    alias T = type-of t;
    alias i = *ip;
    static if (types-equal (T, int)) {
      mixin FNVStep.replace("%V", "t");
      return;
      bool matched;
    }
    static if (types-equal (T, float) || types-equal (T, bool)) {
      mixin FNVStep.replace("%V", "*int*:&t");
      return;
      bool matched;
    }
    static if (!is-defined matched && (type-is tuple T || type-is vector T)) {
      static for (int i <- 0..t.length)
        .hashptr_fnv!type-of &t[i] (&t[i], ip);
      return;
      bool matched;
    }
    static if (!is-defined matched && type-is struct T) {
      static for (int i <- 0..t.tupleof.length) {
        alias entry = t.tupleof[i];
        .hashptr_fnv!type-of &entry (&entry, ip);
      }
      return;
      bool matched;
    }
    static if (!is-defined matched && types-equal (T, string)) {
      string str = t, rest;
      int last;
      if (str.length % 4 != 0) {
        auto marker = str.length - str.length % 4;
        (str, rest) = str[(0..marker, marker..$)];
        for auto ub <- ubyte[]:rest last = (last << 8) + ub;
      }
      for int v <- int[]:str mixin FNVStep.replace("%V", "v");
      mixin FNVStep.replace("%V", "last");
      return;
      bool matched;
    }
    static if (!is-defined matched) {
      pragma(fail, string-of T ~ ": how do I hash web?");
    }
  }
}

template hashptr(PTR) {
  int hashptr(PTR ptr) {
    int res = FNV_offset;
    hashptr_fnv!PTR(ptr, &res);
    return res;
  }
}

template Hashmap(T) {
  alias Key = T[0], Value = T[1];
  alias α = 0.5;
  struct Hashmap {
    (Key key, Value value)[] backing;
    bool[] isset;
    int length;
    float load() {
      pragma(fast);
      if (!backing.length) return 1;
      return length * 1f / backing.length;
    }
    void iterate(void delegate(Key*, Value*) dg) {
      pragma(fast);
      for ref entry <- backing && int i <- ints
        if (isset[i]) dg (&entry[0], &entry[1]);
    }
    void realloc(int newsize) {
      pragma(fast);
      type-of this newmap;
      newmap.backing = new type-of backing newsize;
      newmap.isset = new type-of isset newsize;
      iterate(\(Key* kp, Value* vp) newmap.insert(kp, vp););
      this = newmap;
    }
    Value* insert(Key k, Value v) { return insert(&k, &v); }
    Value* insert(Key* kp, Value* vp) {
      pragma(fast);
      alias k = Key:*kp, v = Value:*vp;
      do auto loadf = load();
      while (loadf > α) {
        auto newsize = backing.length * 2;
        if (!newsize) newsize = 16;
        realloc newsize;
      }
      auto pos = (hashptr &k) % backing.length;
      while (isset[pos]) {
        if (++pos == backing.length) pos = 0;
      }
      backing[pos] = (k, v);
      isset[pos] = true;
      length ++;
      return &backing[pos].value;
    }
    Value* get(Key k) { return get &k; }
    Value* get(Key* kp) {
      pragma(fast);
      alias k = *kp;
      if (!backing.length) return null;
      auto pos = (hashptr &k) % backing.length;
      while (isset[pos]) {
        if (backing[pos].key == k) return &backing[pos].value;
        if (++pos == backing.length) pos = 0;
      }
      return null;
    }
  }
}
