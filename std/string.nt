module std.string;

int find(string text, string match) {
  for (int i = 0; i <= text.length - match.length; ++i) {
    if (text[i .. i+match.length] == match) return i;
  }
  return -1;
}

int rfind(string text, string match) {
  for (int i = text.length - match.length; i >= 0; --i) {
    if (text[i .. i+match.length] == match) return i;
  }
  return -1;
}

string startsWith(string s, string m) {
  if s.length < m.length return null;
  if (s[0 .. m.length] != m)
    return null;
  return s[m.length .. s.length];
}

string endsWith(string s, string m) {
  if s.length < m.length return null;
  if (s[$-m.length .. $] != m)
    return null;
  return s[0 .. $-m.length];
}

string between(string s, string from, string to) {
  int pos1;
  if (from.length) pos1 = find(s, from);
  if (pos1 == -1) return null;
  s = s[pos1 + from.length .. $];
  
  int pos2 = s.length;
  if (to.length) pos2 = find(s, to);
  if (pos2 == -1) return null;
  s = s[0 .. pos2];
  
  return s;
}

// seek to "to" first
string between_r(string s, string from, string to) {
  int pos2 = to.length;
  if (from.length) pos2 = find(s, to);
  if (pos2 == -1) return null;
  s = s[0 .. pos2];
  
  int pos1 = 0;
  if (from.length) pos1 = rfind(s, from);
  if (pos1 == -1) return null;
  s = s[pos1 + from.length .. $];
  
  return s;
}

template join(T) <<EOF
  auto join(T t) {
    static if (type-is-tuple T) <<EO2{
      alias T-type-of = type-of t[0];
      type-of (value-of!iterType!T-type-of)[0] [auto~] res;
      bool first = true;
      while auto chunk <- t[0] {
        if first first = false;
        else res ~= t[1];
        res ~= chunk;
      }
      return res[];
    }EO2 else <<EO2{
      type-of (value-of!iterType!T)[0] [auto~] res;
      while auto chunk <- t { res ~= chunk; }
      return res[];
    }EO2
  }
EOF

template splitAt(T) <<EOF
  class iter {
    T sup;
    char[auto~] buffer;
    string value;
    bool done;
    bool advance() {
      if (done) return false;
      int pos;
      do pos = find (buffer[], sup[0]);
      while pos == -1 {
        if (auto supstep <- sup[1]) { buffer ~= supstep; } else { value = buffer[]; done = true; return true; }
      }
      value = buffer[0 .. pos];
      buffer = type-of buffer: buffer[pos + sup[0].length .. $];
      return true;
    }
  }
  iter splitAt(T t) {
    auto res = new iter;
    res.sup = t;
    return res;
  }
EOF

char* toStringz(string s) {
  char ch;
  auto s2 = new char[](s.length + 1);
  s2[0 .. s.length] = s;
  s2[s.length] = ch;
  return s2.ptr;
}

string CToString(char* c) {
  if !c return string:(null x 2);
  char* cur = c;
  while (*cur) cur++;
  return c[0 .. (int:cur - int:c)];
}

string concat(string[] strs) {
  char[auto~] res;
  while auto str <- strs res ~= str;
  return res[];
}

import c.stdlib;
alias c_atoi = atoi;
alias c_atof = atof;

int atoi(string s) {
  auto p = toStringz(s);
  onExit mem.free(p);
  return c_atoi(p);
}

float atof(string s) {
  char* p = toStringz(s);
  onExit mem.free(p);
  return float:c_atof(p);
}

template castIter(T) <<EOF
  template castIter(U) <<EO2
    class caster {
      U sup;
      T value() {
        return T: evaluate (sup.value);
      }
      bool advance() { return sup.advance(); }
    }
    caster castIter(U u) {
      auto res = new caster;
      res.sup = u;
      return res;
    }
  EO2
EOF

// before, after
(string, string) slice(string s, string m, bool yieldNull = true) {
  auto pos = find(s, m);
  if (pos == -1) {
    if (yieldNull) return (s, string:(null x 2));
    writeln "|$m| not found in |$s| for slice! ";
    _interrupt 3;
  }
  return (s[0 .. pos], s[pos + m.length .. s.length]);
}

string slice(string* sp, string marker, bool yieldNull = true) {
  (string res, *sp) = slice(*sp, marker, yieldNull);
  return res;
}

string strip(string s) {
  alias first = s[0];
  alias last = s[s.length - 1];
  while s.length && (last == "\n" || last == "\r" || last == " " || last == "\t")
    s = s[0 .. s.length - 1];
  while s.length && (first == "\n" || first == "\r" || first == " " || first == "\t")
    s = s[1 .. s.length];
  return s;
}

import std.util;
string[] split(string s, string marker) {
  string[auto~] res;
  string dup(string s) { auto res = new char[] s.length; int i; for (auto ch <- s) res[i++] = ch; return res; }
  for (auto value <- splitAt(marker, iterOnce s))
    res ~= dup value;
  return res[];
}
