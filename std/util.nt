module std.util;

template iterOnce(T) {
  class one : Iterator!T {
    bool done;
    bool advance() {
      if done return false;
      done = true;
      return true;
    }
  }
  one iterOnce(T t) {
    auto res = new one;
    res.value = t;
    return res;
  }
}

template iteratorType(T) {
  alias iteratorType = type-of value-of!T.iterator;
}

template loop(T) {
  class loopclass {
    iteratorType!T running, iter;
    type-of-elem value-of!T value;
    bool advance() {
      if !(value <- running) {
        running = iter;
        if !(value <- running) {
          raise-error new Error "Unable to restore iterator in loop iter! ";
        }
      }
      return true;
    }
  }
  loopclass loop(T t) {
    auto res = new loopclass;
    res.iter = type-of res.iter: t.iterator;
    res.running = type-of res.running: t.iterator;
    return res;
  }
}

template UnreliableIterator(T) {
  class UnreliableIterator : Iterator!T {
    bool canAdvance() { raise-error new Error "$this: UnreliableIterator::canAdvance not implemented!"; }
  }
}

template FeedIterator(T) {
  class FeedIterator : UnreliableIterator!T {
    T[auto~] source;
    int offset;
    void write(T t) { source ~= t; }
    bool canAdvance() { return source.length > 0; }
    bool advance() {
      if (!source.length) raise-error new Error "Feed iterator: buffer empty";
      value = source[0];
      
      // TODO: do this in the compiler
      auto backup = source.capacity;
      source = T[auto~]: source[1..$];
      source.capacity = backup - 1;
      
      return true;
    }
  }
}
