/*Title: std.util
Iterator-related helper functions*/
module std.util;

/*Template: once
For any value, forms an iterator that yields only that value, exactly once. */
template once(T) {
  auto once(T t) {
    class one : Iterator!T {
      bool done;
      bool advance() {
        if done return false;
        done = true;
        return true;
      }
    }
    one res;
    res.value = t;
    return res;
  }
}

/*Template: iterFrom
Skips the first n values from the iterator */
template iterFrom(T) {
  class from : Iterator!type-of-elem T[0] {
    int count;
    type-of (*T[0]*:null).iterator iter;
    void init(T t) { iter = t[0].iterator; count = t[1]; }
    bool advance() {
      for value <- iter {
        if (count) count --;
        else return true;
      }
      return false;
    }
  }
  from iterFrom(T t) {
    return new from t;
  }
}

template iteratorType(T) {
  alias iteratorType = type-of value-of!T.iterator;
}

/*Template: loop
Loops the argument infinitely. Argument must have value semantics! */
template loop(T) {
  class loopclass {
    T safeCopy;
    iteratorType!T running, iter;
    type-of-elem value-of!T value;
    bool advance() {
      if !(value <- running) {
        running = iter;
        if !(value <- running) {
          raise new Error "Unable to restore iterator in loop iter! ";
        }
      }
      return true;
    }
  }
  loopclass loop(T t) {
    auto res = new loopclass;
    res.safeCopy = t;
    res.iter = type-of res.iter: res.safeCopy.iterator;
    res.running = type-of res.running: res.safeCopy.iterator;
    return res;
  }
}

template UnreliableIterator(T) {
  class UnreliableIterator : Iterator!T {
    bool canAdvance() { raise new Error "$this: UnreliableIterator::canAdvance not implemented!"; }
  }
}

/*Template: FeedIterator
A buffer iterator. Yields elements that have been put into it with write(T). 
*/
template FeedIterator(T) {
  class FeedIterator : UnreliableIterator!T {
    T[auto~] source;
    int offset;
    void write(T t) { source ~= t; }
    bool canAdvance() { return source.length > 0; }
    bool advance() {
      if (!source.length) raise new Error "Feed iterator: buffer empty";
      value = source[0];
      
      // TODO: do this in the compiler
      auto backup = source.capacity;
      source = T[auto~]: source[1..$];
      source.capacity = backup - 1;
      
      return true;
    }
  }
}

template flatten(T) {
  template Flatten(T) {
    class Flatten : Iterator!T {
      Iterator!T[] sup;
      T[] backing;
      void init(Iterator!T[] s) { sup = s; }
      bool advance() {
        if (!backing.length) {
          if (!sup || !backing <- sup) { sup = null; return false; }
        }
        (value, backing) = backing[(0, 1..$)];
        return true;
      }
    }
  }
  auto flatten(T t) {
    alias Elem = type-of-elem value-of!type-of-elem t;
    return new Flatten!Elem(t);
  }
}

/*Template: take
Takes a number of elements from an iterator and returns them as an array. */
template take(T) {
  auto take(T t) {
    alias Elem = type-of-elem t[0];
    Elem[auto~] res;
    for 0..t[1] {
      if auto val <- t[0] res ~= val;
      else raise new Error "Not enough elements available to take $(t[1])";
    }
    return res[];
  }
}

/// head frees the input iterator!!
template head(T) {
  auto head(T t) {
    if auto val <- t {
      using t static if (is-defined local free) {
        free;
      }
      return val;
    } else raise new Error "No elements left in $t";
  }
}

macro("tree.expr.flatten_tuple", "331") `
  (if
    (not (matched-text "__flatten_tuple"))
    'nil
    '(last
      (def 'tup (parse-tuple))
      (def 'unroll (lambda '(e)
        '(if (not (is-tuple e))
          'e
          '(for (tuple-exprs e) 'e2 '(unroll e2)))))
      (make-tuple-expr (flatten (unroll tup)))))
`;

template apply(T) {
  auto apply(T t) {
    alias FT = T[1];
    alias PT = ParamTypes FT;
    // pragma(msg, string-of PT);
    alias pt = value-of!PT;
    static if (type-is tuple PT) {
      alias Rest = type-of pt[1..pt.length];
      return new \(Rest rest) {
        // pragma(msg, string-of type-of t[1]~" # "~string-of type-of (__flatten_tuple (t[0], rest)));
        return t[1] (__flatten_tuple (t[0], rest));
      }
    } else {
      return new \{ return t[1] t[0]; }
    }
  }
}

template rapply(T) {
  auto rapply(T t) {
    alias FT = T[1];
    alias PT = ParamTypes FT;
    // pragma(msg, string-of PT);
    alias pt = value-of!PT;
    static if (type-is tuple PT) { alias Rest = type-of pt[0..pt.length-1]; }
    else { alias Rest = type-of (); }
    return new \(Rest rest) {
      // pragma(msg, string-of type-of t[1]~" # "~string-of type-of (__flatten_tuple (t[0], rest)));
      return t[1] (__flatten_tuple (rest, t[0]));
    }
  }
}

template reverse(T) {
  alias IT = type-of-elem T;
  class rev : Iterator!IT {
    IT[] back;
    int pos;
    bool advance() {
      if (pos == -1) { free; return false; }
      value = back[pos];
      pos--;
      if (pos == -1) back.free;
      return true;
    }
  }
  auto reverse(T t) using new rev {
    back = t.iterator.eval[];
    pos = back.length - 1;
    return that;
  }
}
