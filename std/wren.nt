/**
<feep> so
<feep> Ralith
<feep> name for my lisp
<feep> thing
<Ralith> feeparen
<feep> can't pronounce that
<Ralith> ...?
<feep> I keep trying to say it "feep a ren"
<Ralith> that is how you pronounce it!
<feep> what is a ren
<feep> and how do you feep it
<Ralith> a wren is a kind of bird
<feep> std.wren?
<Ralith> presumably you feep it by flailing in its direction
<feep> oh. looks tiny and loud. perfect.
**/
module std.wren;

class WrenError : Error {
  string unadorned-str;
  void init(string s) { super.init "WrenError: $s"; unadorned-str = s; }
}

void error(string s) { raise new WrenError s; }

interface Thing;

interface Namespace {
  Thing lookup(string match);
  void iterate(void delegate(string, Thing) dg);
}

interface Thing {
  Thing eval(Namespace);
  string toString();
}

class Token : Thing {
  string name;
  void init(string s) name = s;
  Thing eval(Namespace ns) {
    auto res = ns.lookup name;
    if (!res) error "Cannot evaluate $this: no $name found in $ns";
    return res;
  }
  string toString() { return "$name"; }
}

class Number : Thing {
  float num;
  void init(float f) num = f;
  Thing eval(Namespace) { return number-eval?this:this; } // trap for C coders
  string toString() { return "$num"; }
}
Thing delegate(Number) number-eval;

class Integer : Thing {
  int num;
  void init(int i) num = i;
  Thing eval(Namespace) { return this; }
  string toString() { return "$num"; }
}

class Vec2f : Thing {
  vec2f value;
  void init(vec2f v) value = v;
  Thing eval(Namespace) { return this; }
  string toString() { return "vec2f($(value.x), $(value.y))"; }
}

class Vec3f : Thing {
  vec3f value;
  void init(vec3f v) value = v;
  Thing eval(Namespace) { return this; }
  string toString() { return "vec3f($(value.x), $(value.y), $(value.z))"; }
}

class Vec4f : Thing {
  vec4f value;
  void init(vec4f v) value = v;
  Thing eval(Namespace) { return this; }
  string toString() { return "vec4f($(value.x), $(value.y), $(value.z), $(value.w))"; }
}

interface IArray : Thing {
  Thing getIndex(int i);
  int getLength();
  IArray concat(IArray);
}

interface Assignable {
  void assign(Thing newval);
}

interface WrenObject {
  Thing lookup(string name);
}

template Array(T) {
  class Array : Thing, IArray {
    T[] value;
    void init(T[] t) { value = t; }
    Thing eval(Namespace ns) { return this; } // value type
    Thing getIndex(int i) {
      return neat-to-wren value[i];
    }
    IArray concat(IArray b) {
      auto arr = Array:b;
      if (!arr) error
        "Incompatible arrays for concatenation: $(string-of T) and $b";
      return new Array $ value ~ arr.value;
    }
    int getLength() { return value.length; }
    string toString() {
      return "$(string-of T)[] $value";
    }
  }
}

alias String = Array!char;

IArray array-from-thing(Thing t) {
  if (auto num = Number:t) using new Array!float null {
    value ~= num.num;
    return that;
  }
  if (auto vec = Vec2f:t) using new Array!vec2f null {
    value ~= vec.value;
    return that;
  }
  if (auto vec = Vec3f:t) using new Array!vec3f null {
    value ~= vec.value;
    return that;
  }
  if (auto vec = Vec4f:t) using new Array!vec4f null {
    value ~= vec.value;
    return that;
  }
  raise new Error "Cannot construct array from $t";
}

template Reference(T) {
  class Reference : Thing, Assignable {
    T* ptr;
    void init(T* t) { ptr = t; }
    Thing eval(Namespace) { return neat-to-wren *ptr; }
    void assign(Thing newval) {
      *ptr = wren-to-neat!T newval;
    }
    string toString() { return "&$(*ptr)"; }
  }
}

template neat-to-wren(T) {
  Thing neat-to-wren(T t) {
    static if (implicitly-converts-to Thing t) {
      return t;
      alias match-found = true;
    }
    static if (!is-defined match-found && implicitly-converts-to Object t) {
      return new ObjectThing t;
      alias match-found = true;
    }
    static if (!is-defined match-found && types-equal (bool, T)) {
      if (t) return .t;
      else return nil;
      alias match-found = true;
    }
    static if (!is-defined match-found && implicitly-converts-to int t) {
      return new Integer t;
      alias match-found = true;
    }
    static if (!is-defined match-found && implicitly-converts-to float t) {
      return new Number t;
      alias match-found = true;
    }
    static if (!is-defined match-found && implicitly-converts-to vec2f t) {
      return new Vec2f t;
      alias match-found = true;
    }
    static if (!is-defined match-found && implicitly-converts-to vec3f t) {
      return new Vec3f t;
      alias match-found = true;
    }
    static if (!is-defined match-found && implicitly-converts-to vec4f t) {
      return new Vec4f t;
      alias match-found = true;
    }
    static if (!is-defined match-found && type-is array T) {
      alias AT = type-of t[0];
      return new Array!AT t;
      alias match-found = true;
    }
    static if (!is-defined match-found && type-is tuple T) {
      Thing[auto~] entries;
      static for int i <- 0..t.length {
        entries ~= .neat-to-wren t[i];
      }
      return new List entries[];
      alias match-found = true;
    }
    static if !is-defined match-found && (type-is delegate T || type-is function T) {
      return new Function("neat wrapper for $(string-of T)", new delegate Thing(Thing[] args) {
        alias PT = ParamTypes T;
        PT neatargs;
        static if (type-is tuple PT) {
          if (args.length != neatargs.length) error "Neat function $(string-of T) called with wrong number of arguments: $args";
          static if neatargs.length {
            static for int i <- 0..neatargs.length {
              neatargs[i] = wren-to-neat!type-of neatargs[i] args[i];
            }
            alias call = t neatargs;
          } else {
            alias call = t();
          }
        } else {
          if (args.length != 1) error "Neat function $(string-of T) called with wrong number of arguments: $args";
          neatargs = wren-to-neat!type-of neatargs args[0];
          alias call = t neatargs;
        }
        static if (types-equal (void, type-of call)) {
          call;
          return .t;
        } else {
          return .neat-to-wren call;
        }
      });
      alias match-found = true;
    }
    static if (!is-defined match-found) {
      pragma(fail, string-of type-of t ~ ": can't convert to wren form");
    }
  }
}

template wren-to-neat(T) {
  T wren-to-neat(Thing thing) {
    static if (type-is class T) || (type-is interface T) {
      if (auto as = Assignable: thing) thing = thing.eval(null); // get at the juicy value beneath
      if (auto ot = ObjectThing: thing) {
        if (auto res = T: ot.obj) return res;
      }
      return null;
      // error "Can't convert to $(string-of T): $thing";
      alias match-found = true;
    }
    static if (type-is array T) {
      alias AT = type-of (*T*:null)[0];
      if (auto arr = Array!AT: thing)
        return arr.value;
      else error "Can't create $(string-of T) ($(string-of AT)) from $thing";
      alias match-found = true;
    }
    static if (types-equal(bool, T)) {
      if (is-nil thing) return false;
      if (is-t thing) return true;
      error "Can't create bool from $thing: neither nil nor t";
      alias match-found = true;
    }
    static if (types-equal(int, T)) {
      if (auto i = Integer: thing) {
        return i.num;
      }
      if (auto n = Number: thing) {
        import std.math;
        if (abs(int:n.num - n.num) > 0.001)
          error "Cannot convert to int: $thing";
        return int:n.num;
      }
      else error "Can't create int from $thing";
      alias match-found = true;
    }
    static if (types-equal(float, T)) {
      if (auto n = Number: thing)
        return n.num;
      else error "Can't create float from $thing";
      alias match-found = true;
    }
    static if (types-equal(vec2f, T)) {
      if (auto v2 = Vec2f: thing)
        return v2.value;
      else error "Can't create vec2f from $thing";
      alias match-found = true;
    }
    static if (types-equal(vec3f, T)) {
      if (auto v3 = Vec3f: thing)
        return v3.value;
      else error "Can't create vec3f from $thing";
      alias match-found = true;
    }
    static if (types-equal(vec4f, T)) {
      if (auto v4 = Vec4f: thing)
        return v4.value;
      else error "Can't create vec4f from $thing";
      alias match-found = true;
    }
    static if (type-is tuple T) {
      T res;
      
      auto li = List: thing;
      if !li || li.list.length != res.length
        error "Can't create $(string-of T) from $thing";
      
      static for int i <- 0..res.length {
        alias restype = type-of res[i];
        res[i] = .wren-to-neat!restype li.list[i];
      }
      return res;
      alias match-found = true;
    }
    static if (type-is delegate T) {
      auto fn = Function: thing;
      if !fn error "Can't create $(string-of T) from $thing: not a Function";
      alias Ret = ReturnType T, Par = ParamTypes T;
      return __internal_flatten new delegate Ret(Par p) {
        Thing[auto~] neatargs;
        static if (type-is tuple Par) {
          static for int i <- 0..p.length {
            neatargs ~= neat-to-wren p[i];
          }
        } else {
          neatargs ~= neat-to-wren p;
        }
        auto res = fn.call (neatargs[], scripts);
        return (.wren-to-neat!Ret) res;
      }
      alias match-found = true;
    }
    static if (!is-defined match-found) {
      pragma(fail, string-of T ~ ": can't create from wren form");
    }
  }
}

class ObjectThing : Thing {
  Object obj;
  void init(Object obj) { this.obj = obj; if (!obj) error "Tried to make null ObjectThing"; }
  Thing eval(Namespace) { return this; }
  string toString() { return "$obj"; }
}

interface Operator {
  Thing call(Thing[] args, Namespace ns);
  /**
    is called with rest of list, unevaluated
    calls back all things that may be evalled later
    provided callback can be invoked for any name to get a "marker" indicating the origin of the name
    markers shall be identical for names that resolve to the same thing, or null for names not overridden.
  **/
  void boundnames(Thing[] args, Thing delegate(Thing, Object delegate(string)) dg);
}

class Function : Thing, Operator {
  string info;
  Thing delegate(Thing[]) fn;
  Thing delegate(Thing[], Namespace) fn2;
  void init(string s, Thing delegate(Thing[]) dg) (info, fn) = (s, dg);
  void init(string s, Thing delegate(Thing[], Namespace) dg) (info, fn2) = (s, dg);
  void boundnames(Thing[] args, Thing delegate(Thing, Object delegate(string)) dg) {
    // (<fun> args) does not affect the lexical evaluation of args at all
    for ref arg <- args
      arg = dg(arg, λ(string s) { return Object:null; });
  }
  Thing call(Thing[] list, Namespace ns) {
    // onFailure writeln "while calling $info";
    scope Thing[auto~] args;
    for auto thing <- list
      args ~= thing.eval ns;
    return direct-call(args[], ns);
  }
  // call without evaluating
  Thing direct-call(Thing[] args, Namespace ns) {
    if (fn2) return fn2 (args[], ns);
    else return fn args[];
  }
  Thing eval(Namespace) {
    error "Cannot evaluate $this";
  }
  string toString() { return "{$info}"; }
}

class Escape : Thing {
  Thing inside;
  void init(Thing t) inside = t;
  Thing eval(Namespace) { return inside; }
  string toString() { return "'$inside"; }
}

class List : Thing {
  Thing[] list;
  void init(Thing[] l) { list = l; }
  Thing eval(Namespace ns) {
    if !list.length error "Cannot evaluate $this: list empty";
    // writeln "Evaluate $this";
    auto op = Operator: auto first = list[0].eval(ns);
    if !op error "Cannot evaluate $this: first entry is not an operator (function), but $(first?.toString():\"null\")";
    {
      auto tok = Token:list[0];
      if (!Function:op && !tok)
        error "Sanity failure in $this: first entry is not token, but does not resolve to function; instead, $op. This breaks no-rebinding-operators.";
    }
    return op.call (list[1..$], ns);
  }
  string toString() {
    char[auto~] res;
    res ~= "(";
    for auto thing <- list && int i <- ints {
      if i res ~= " ";
      res ~= thing?.toString():"(null)";
    }
    res ~= ")";
    return res[];
  }
}

class IntValue : Thing, Assignable {
  int* target;
  void init(int* ip) target = ip;
  string toString() { return "<ref $(*target)>"; }
  Thing eval(Namespace ns) {
    return new Number(*target);
  }
  void assign(Thing t) {
    auto n = Number:t;
    if !n error "Cannot assign: $t is not a number";
    *target = int: n.num;
  }
}

class FloatValue : Thing, Assignable {
  float* target;
  void init(float* fp) target = fp;
  string toString() { return "<ref $(*target)>"; }
  Thing eval(Namespace ns) {
    return new Number(*target);
  }
  void assign(Thing t) {
    auto n = Number:t;
    if !n error "Cannot assign: $t is not a number";
    *target = float: n.num;
  }
}

class ObjectValue : Thing {
  Object* target;
  void init(Object* op) target = op;
  string toString() { return "<ref $(*target)>"; }
  Thing eval(Namespace ns) {
    return new String "$(*target)";
  }
}

class DataArray : Thing {
  (int, void*)* target;
  void init((int, void*)* ap) target = ap;
  string toString() { return "<data-array $(*target#[0]): $(*target#[1])>"; }
  Thing eval(Namespace ns) {
    error "Cannot evaluate data-array";
  }
}

import std.string;

bool accept(string* text, string match) {
  string t2 = *text #.strip();
  if (auto rest = t2.startsWith(match)) { *text = rest; return true; }
  return false;
}

extern(C) float strtof(char* sptr, char** endptr);
bool gotNum(string* text, float* num) {
  float res = 0;
  auto t2 = *text #.strip();
  scope char[auto~] n;
  while (t2.length && ("0" <= t2[0] <= "9" || t2[0] == "." || t2[0] == "-")) {
    n ~= t2[0]; t2 = t2[1..$];
  }
  if (!n.length) return false;
  scope nptr = toStringz n[];
  char* endptr;
  *num = nptr.strtof(&endptr);
  if (endptr !is nptr + n.length) return false;
  *text = t2;
  return true;
}

Thing parse(string* text) {
  if (text.accept "(") {
    Thing[auto~] things;
    while (!text.accept ")")
      things ~= parse text;
    return new List things[];
  }
  if (gotNum(text, &float f)) {
    return new Number f;
  }
  if (text.accept("\"")) {
    auto str = slice(text, "\"");
    return new String str;
  }
  if (text.accept("'")) {
    return new Escape (parse text);
  }
  if (text.accept(";")) {
    *text = *text #.between("\n", ""); // eat a line
    return parse(text); // and retry
  }
  auto t2 = *text #.strip();
  char[auto~] token;
  while (t2.length && t2[0] != " " && t2[0] != ")" && t2[0] != "(" && t2[0] != "\r" && t2[0] != "\n") {
    token ~= t2[0];
    t2 = t2[1..$];
  }
  if (!token.length)
    error "Don't know what to do at $t2";
  *text = t2;
  return new Token token[];
}

class MultiNamespace : Namespace {
  Namespace[auto~] set;
  void add(Namespace ns) { set ~= ns; }
  string toString() { return "mns $(set[])"; }
  Thing lookup(string match) {
    for auto ns <- set if auto res = ns.lookup(match) return res;
    return null;
  }
  void iterate(void delegate(string, Thing) dg) {
    for auto ns <- set ns.iterate dg;
  }
}

class ListNamespace : Namespace {
  (Thing, string)[auto~] list;
  void add(string name, Thing t) {
    list ~= (t, name);
  }
  Thing lookup(string match) {
    for ref entry <- list
      if (entry[1] == match)
        return entry[0];
    return null;
  }
  string toString() {
    auto temp = [for tup <- list: tup[1]].eval;
    onExit temp.free;
    return "$(temp[])";
  }
  void iterate(void delegate(string, Thing) dg) {
    for auto pair <- list
      dg pair[(1, 0)];
  }
}

ListNamespace scripts; // default namespace

shared Thing nil, t;
void init() {
  nil = new List null;
  auto arr = new Thing[] 1;
  arr[0] = nil;
  t = new List arr;
}

bool is-nil(Thing th) {
  auto l = List:th;
  return l && !l.list;
}

bool is-t(Thing th) {
  auto l = List:th;
  return l && l.list.(length == 1 && is-nil _0);
}

string commentstrip(string s) {
  while (true) {
    s = s.strip();
    if (auto rest = s.startsWith ";") s = rest.between("\n", "");
    else break;
  }
  return s;
}
