/*Title: std.math
Math functions */
module std.math;

import c.math;

/*Function: cross3f
The vector cross product*/
vec3f cross3f(vec3f a, vec3f b) { pragma(fast); return a.yzx * b.zxy - a.zxy * b.yzx; }

/*Function: sqrt
Square root. Gets inlined. */
alias sqrt = sqrtf;

// http://www.lomont.org/math/papers/2003/invsqrt.pdf
float fastinvsqrt(float f) {
  pragma(fast);
  float half = 0.5f*f;
  int i = *int*:&f;
  i = 0x5f3759df - (i>>1);
  f = *float*:&i;
  f = f*(1.5f-half*f*f);
  return f;
}

/*Function: angle3f
Angle between two vectors, optionally in reference to a third vector
credit to http://tomyeah.com/signed-angle-between-two-vectors3d-in-cc/ */
float angle3f(vec3f v, vec3f to, vec3f refer = vec3f(0)) {
  pragma(fast);
  auto v1 = v.cross3f(to) * refer;
  bool flipped = v1.sum < 0;
  auto ratio = (v*to).sum / sqrt(v.selfdot * to.selfdot);
  float res = void;
  // rounding errors here are a recipe for NaNs, so avoid by clamping
  if (ratio <= -1) res = PI;
  else if (ratio >= 1) res = 0;
  else res = acosf ratio;
  // fudge
  if (flipped) res = -res;
  return res;
}

/*Function: rotate3f
Rotates *vec* around *axis* by *angle*. */
vec3f rotate3f(vec3f vec, vec3f axis, float angle) using vec {
  float u = axis.x, v = axis.y, w = axis.z;
  float uu = u*u, vv = v*v, ww = w*w;
  float v_w = vv + ww, u_w = uu + ww, u_v = uu + vv;
  float dd = (vec*axis).sum, cosa = cosf(angle), sina = sinf(angle);
  vec3f res = void;
  // pathologically slow to parse
  /*res = axis * dd
    + (vec * vec3f(v_w, u_w, u_v) + axis * (axis.yxx*(-vec.yxx) + axis.zzy * (-vec.zzy))) * cosa
    + (axis.zzy * vec3f (vec.(-y, x, -x)) + axis.yxx * vec3f(vec.(z, -z, y))) * sina;*/
  res.x = u*dd+(x*v_w+u*(v*(-y)+w*(-z))) * cosa + (w*(-y)+v*z) * sina;
  res.y = v*dd+(y*u_w+v*(u*(-x)+w*(-z))) * cosa + (w*x+u*(-z)) * sina;
  res.z = w*dd+(z*u_v+w*(u*(-x)+v*(-y))) * cosa + (v*(-x)+u*y) * sina;
  res /= axis.lensq;
  return res;
}

/*Function: sin
The sine function*/
float sin(float x) {
  // thanks to devmaster.net/forums/topic/4648-fast-and-accurate-sinecosine/ 
  alias B = 4/PI;
  alias C = -4/(PI*PI);
  
  // wrap to -PI .. PI
  x += PI; // wrap to 0..2PI
  x -= 2*PI*floorf(x/(2*PI));
  x -= PI; // and back
  
  float y = B * x + C * x * abs x;
  
  // #ifdef EXTRA_PRECISION
  //  alias Q = 0.775;
      alias P = 0.225;

      y = P * (y * abs y - y) + y;   // Q * y + P * y * abs(y)
  // #endif
  return y;
}

/*Function: cos
The cosine function*/
float cos(float x) {
  return sin float:$ PI/2 - x;
}

/*Function: half
Convenience wrapper*/
vec2f half(vec2f a, b) return (a + b) / 2;
/*Function: half
Convenience wrapper*/
vec3f half(vec3f a, b) return (a + b) / 2;
/*Function: half
Convenience wrapper*/
vec4f half(vec4f a, b) return (a + b) / 2;

/*Function: is-nan
Tests if its argument is the floating-point special value NaN*/
bool is-nan(float f) {
  int i = *int*:&f;
  return (i & 0x7fff_ffff) > 0x7f80_0000;
}

extern(C) {
  float floorf(float x);
  float ceilf(float x);
}

/*Function: floor*/
float floor(float x) { return floorf x; }
/*Function: ceil*/
float ceil(float x) { return ceilf x; }
/*Function: atan*/
float atan(float x) { return atanf x; }

/*Function: abs*/
int abs(int i) { if i < 0 return -i; return i; }
/*Function: abs*/
float abs(float f) { if f < 0 return -f; return f; }
/*Function: abs*/
double abs(double d) { if d < 0 return -d; return d; }

/*Function: bound
  Limits f to {from, to} by clamping*/
float bound(float from, to, f) {
  if (f < from) f = from;
  if (f > to) f = to;
  return f;
}

/*Function: wrap
  Limits f to {from, to} by wrapping*/
float wrap(float from, to, f) {
  auto sz = to - from;
  if (f < from) f += floor((to - f) / sz) * sz;
  if (f > to) f -= floor((f - from) / sz) * sz;
  return f;
}

/*Alias: PI*/
alias PI = 3.1415926538;
alias π = PI;
/*Alias: PI2*/
alias PI2 = PI * 2;
/*Alias: TAU*/
alias TAU = PI2;
alias τ = TAU;
/*Alias: PI180*/
alias PI180 = PI/180.0;

/*Alias: pow*/
alias pow = powf;
/*Alias: log*/
alias _Clog = log, log = _Clog, log = logf;
/*Alias: log*/
alias log = logf;
/*Alias: log2*/
alias log2 = log2f;
/*Alias: exp*/
alias exp = expf;
/*Alias: exp2*/
alias exp2 = exp2f;
/*Alias: atan2*/
alias atan2 = atan2f;
/*Alias: asin*/
alias asin = asinf;
/*Alias: acos*/
alias acos = acosf;

/*Template: min
Returns the smaller of its two parameters*/
template min(T) {
  auto min(T t) {
    static if (t.length != 2) {
      pragma(fail, string-of type-of t~": please only pass two parameters to min");
    }
    // TODO: generically distribute over vectors
    static if (types-equal(vec2f, T[0])) {
      return vec2f(.min(t[0].x, t[1].x), .min(t[0].y, t[1].y));
    } else {
      static if (types-equal(vec3f, T[0])) {
        return vec3f(.min(t[0].x, t[1].x), .min(t[0].y, t[1].y), .min(t[0].z, t[1].z));
      } else {
        if (t[0] > t[1]) return t[1];
        return t[0];
      }
    }
  }
}

/*Template: max
Returns the larger of its two parameters*/
template max(T) {
  auto max(T t) {
    static if (t.length != 2) {
      pragma(fail, string-of type-of t~": please only pass two parameters to max");
    }
    static if (types-equal(vec2f, T[0])) {
      return vec2f(.max(t[0].x, t[1].x), .max(t[0].y, t[1].y));
    } else {
      static if (types-equal(vec3f, T[0])) {
        return vec3f(.max(t[0].x, t[1].x), .max(t[0].y, t[1].y), .max(t[0].z, t[1].z));
      } else {
        if (t[0] > t[1]) return t[0];
        return t[1];
      }
    }
  }
}

/*Template: minlist
Returns the smallest entry of the iterable argument*/
template minlist(T) {
  type-of-elem value-of!T minlist(T t) {
    eval auto res <- t;
    while auto r2 <- t if r2 < res res = r2;
    return res;
  }
}

/*Template: maxlist
Returns the largest entry of the iterable argument*/
template maxlist(T) {
  type-of-elem value-of!T maxlist(T t) {
    eval auto res <- t;
    while auto r2 <- t if r2 > res res = r2;
    return res;
  }
}
