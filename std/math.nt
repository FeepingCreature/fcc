/*Title: std.math
Math functions */
module std.math;

import c.math;

/*Function: cross3f
The vector cross product*/
vec3f cross3f(vec3f a, vec3f b) { pragma(fast); return a.yzx * b.zxy - a.zxy * b.yzx; }

/*Function: sqrt
Square root. Gets inlined. */
alias sqrt = sqrtf;

// http://www.lomont.org/math/papers/2003/invsqrt.pdf
float fastinvsqrt(float f) {
  pragma(fast);
  float half = 0.5f*f;
  int i = *int*:&f;
  i = 0x5f3759df - (i>>1);
  f = *float*:&i;
  f = f*(1.5f-half*f*f);
  return f;
}

/*Function: angle3f
Angle between two vectors, optionally in reference to a third vector
credit to http://tomyeah.com/signed-angle-between-two-vectors3d-in-cc/ */
float angle3f(vec3f v, vec3f to, vec3f refer = vec3f(0)) {
  pragma(fast);
  auto v1 = v.cross3f(to) * refer;
  bool flipped = v1.sum < 0;
  auto ratio = (v*to).sum / sqrt(v.selfdot * to.selfdot);
  float res = void;
  // rounding errors here are a recipe for NaNs, so avoid by clamping
  if (ratio <= -1) res = PI;
  else if (ratio >= 1) res = 0;
  else res = acosf ratio;
  // fudge
  if (flipped) res = -res;
  return res;
}

/*Function: rotate3f
Rotates *vec* around *axis* by *angle*. */
vec3f rotate3f(vec3f vec, vec3f axis, float angle) using vec {
  float u = axis.x, v = axis.y, w = axis.z;
  float uu = u*u, vv = v*v, ww = w*w;
  float v_w = vv + ww, u_w = uu + ww, u_v = uu + vv;
  float dd = (vec*axis).sum, cosa = cosf(angle), sina = sinf(angle);
  vec3f res = void;
  // pathologically slow to parse
  /*res = axis * dd
    + (vec * vec3f(v_w, u_w, u_v) + axis * (axis.yxx*(-vec.yxx) + axis.zzy * (-vec.zzy))) * cosa
    + (axis.zzy * vec3f (vec.(-y, x, -x)) + axis.yxx * vec3f(vec.(z, -z, y))) * sina;*/
  res.x = u*dd+(x*v_w+u*(v*(-y)+w*(-z))) * cosa + (w*(-y)+v*z) * sina;
  res.y = v*dd+(y*u_w+v*(u*(-x)+w*(-z))) * cosa + (w*x+u*(-z)) * sina;
  res.z = w*dd+(z*u_v+w*(u*(-x)+v*(-y))) * cosa + (v*(-x)+u*y) * sina;
  res /= axis.lensq;
  return res;
}

/*Function: sin
The sine function*/
float sin(float x) {
  // thanks to devmaster.net/forums/topic/4648-fast-and-accurate-sinecosine/ 
  alias B = 4/PI;
  alias C = -4/(PI*PI);
  
  // wrap to -PI .. PI
  x += PI; // wrap to 0..2PI
  x -= 2*PI*floorf(x/(2*PI));
  x -= PI; // and back
  
  float y = B * x + C * x * abs x;
  
  // #ifdef EXTRA_PRECISION
  //  alias Q = 0.775;
      alias P = 0.225;

      y = P * (y * abs y - y) + y;   // Q * y + P * y * abs(y)
  // #endif
  return y;
}

/*Function: cos
The cosine function*/
float cos(float x) {
  return sin $ PI/2 - x;
}

/*Function: half
Convenience wrapper*/
vec2f half(vec2f a, b) return (a + b) / 2;
/*Function: half
Convenience wrapper*/
vec3f half(vec3f a, b) return (a + b) / 2;
/*Function: half
Convenience wrapper*/
vec4f half(vec4f a, b) return (a + b) / 2;

/*Function: is-nan
Tests if its argument is the floating-point special value NaN*/
bool is-nan(float f) {
  int i = *int*:&f;
  return (i & 0x7fff_ffff) > 0x7f80_0000;
}

extern(C) {
  float floorf(float x);
  float ceilf(float x);
}

/*Function: floor*/
float floor(float x) { return floorf x; }
/*Function: ceil*/
float ceil(float x) { return ceilf x; }
/*Function: atan*/
float atan(float x) { return atanf x; }

/*Function: abs*/
int abs(int i) { if i < 0 return -i; return i; }
/*Function: abs*/
float abs(float f) { if f < 0 return -f; return f; }
/*Function: abs*/
double abs(double d) { if d < 0 return -d; return d; }

/*Function: bound
  Limits f to {from, to} by clamping*/
float bound(float from, to, f) {
  if (f < from) f = from;
  if (f > to) f = to;
  return f;
}

/*Function: wrap
  Limits f to {from, to} by wrapping*/
float wrap(float from, to, f) {
  auto sz = to - from;
  if (f < from) f += floor((to - f) / sz) * sz;
  if (f > to) f -= floor((f - from) / sz) * sz;
  return f;
}

/*Alias: PI*/
alias PI = 3.1415926538;
alias π = PI;
/*Alias: PI2*/
alias PI2 = PI * 2;
/*Alias: TAU*/
alias TAU = PI2;
alias τ = TAU;
/*Alias: PI180*/
alias PI180 = PI/180.0;

/*Alias: pow*/
alias pow = powf;
/*Alias: log*/
alias _Clog = log, log = _Clog, log = logf;
/*Alias: log*/
alias log = logf;
/*Alias: log2*/
alias log2 = log2f;
/*Alias: exp*/
alias exp = expf;
/*Alias: exp2*/
alias exp2 = exp2f;
/*Alias: atan2*/
alias atan2 = atan2f;
/*Alias: asin*/
alias asin = asinf;
/*Alias: acos*/
alias acos = acosf;

/*Template: min
Returns the smaller of its two parameters*/
template min(T) {
  auto min(T t) {
    static if (t.length != 2) {
      pragma(fail, string-of type-of t~": please only pass two parameters to min");
    }
    // TODO: generically distribute over vectors
    static if (types-equal(vec2f, T[0])) {
      return vec2f(.min(t[0].x, t[1].x), .min(t[0].y, t[1].y));
    } else {
      static if (types-equal(vec3f, T[0])) {
        return vec3f(.min(t[0].x, t[1].x), .min(t[0].y, t[1].y), .min(t[0].z, t[1].z));
      } else {
        if (t[0] > t[1]) return t[1];
        return t[0];
      }
    }
  }
}

/*Template: max
Returns the larger of its two parameters*/
template max(T) {
  auto max(T t) {
    static if (t.length != 2) {
      pragma(fail, string-of type-of t~": please only pass two parameters to max");
    }
    static if (types-equal(vec2f, T[0])) {
      return vec2f(.max(t[0].x, t[1].x), .max(t[0].y, t[1].y));
    } else {
      static if (types-equal(vec3f, T[0])) {
        return vec3f(.max(t[0].x, t[1].x), .max(t[0].y, t[1].y), .max(t[0].z, t[1].z));
      } else {
        if (t[0] > t[1]) return t[0];
        return t[1];
      }
    }
  }
}

/*Template: minlist
Returns the smallest entry of the iterable argument*/
template minlist(T) {
  type-of-elem value-of!T minlist(T t) {
    eval auto res <- t;
    while auto r2 <- t if r2 < res res = r2;
    return res;
  }
}

/*Template: maxlist
Returns the largest entry of the iterable argument*/
template maxlist(T) {
  type-of-elem value-of!T maxlist(T t) {
    eval auto res <- t;
    while auto r2 <- t if r2 > res res = r2;
    return res;
  }
}

// thanks, intel
void matrix4x4-invert(float x 16* matp) {
  pragma(fast);
  float x 16 tmp = void; /* temp array for pairs */
  float x 16 src = void; /* array of transpose source matrix */
  float x 16 dst = void; /* destination array */
  float det;      /* determinant */
  alias mat = *matp;
  alias matv = *vec4f x 4*:matp;
  alias tmpv = *vec4f x 3*:&tmp;
  alias srcv = *vec4f x 4*:&src;
  alias dstv = *vec4f x 4*:&dst;
  /* transpose matrix */
  for int i <- 0..4 {
    src[i]      = mat[i*4];
    src[i + 4]  = mat[i*4 + 1];
    src[i + 8]  = mat[i*4 + 2];
    src[i + 12] = mat[i*4 + 3];
  }
  /* calculate pairs for first 8 elements (cofactors) */
  alias UseSSE = 0; // not worth it because sse/fpu transitions are S L O W
  static if (UseSSE) {
    tmpv[0] = srcv[2].zwyw*srcv[3].wzwy;
    tmpv[1] = srcv[2].yzxw*srcv[3].zywx;
    tmpv[2] = srcv[2].xzxy*srcv[3].zxyx;
  } else {
    tmp[0]  = src[10]*src[15];
    tmp[1]  = src[11]*src[14];
    tmp[2]  = src[9]*src[15];
    tmp[3]  = src[11]*src[13];
    tmp[4]  = src[9]*src[14];
    tmp[5]  = src[10]*src[13];
    tmp[6]  = src[8]*src[15];
    tmp[7]  = src[11]*src[12];
    tmp[8]  = src[8]*src[14];
    tmp[9]  = src[10]*src[12];
    tmp[10] = src[8]*src[13];
    tmp[11] = src[9]*src[12];
  }
  /* calculate first 8 elements (cofactors) */
  dst[0]  = tmp[0]*src[5] + tmp[3]*src[6] + tmp[4]*src[7];
  dst[0] -= tmp[1]*src[5] + tmp[2]*src[6] + tmp[5]*src[7];
  dst[1]  = tmp[1]*src[4] + tmp[6]*src[6] + tmp[9]*src[7];
  dst[1] -= tmp[0]*src[4] + tmp[7]*src[6] + tmp[8]*src[7];
  dst[2]  = tmp[2]*src[4] + tmp[7]*src[5] + tmp[10]*src[7];
  dst[2] -= tmp[3]*src[4] + tmp[6]*src[5] + tmp[11]*src[7];
  dst[3]  = tmp[5]*src[4] + tmp[8]*src[5] + tmp[11]*src[6];
  dst[3] -= tmp[4]*src[4] + tmp[9]*src[5] + tmp[10]*src[6];
  dst[4]  = tmp[1]*src[1] + tmp[2]*src[2] + tmp[5]*src[3];
  dst[4] -= tmp[0]*src[1] + tmp[3]*src[2] + tmp[4]*src[3];
  dst[5]  = tmp[0]*src[0] + tmp[7]*src[2] + tmp[8]*src[3];
  dst[5] -= tmp[1]*src[0] + tmp[6]*src[2] + tmp[9]*src[3];
  dst[6]  = tmp[3]*src[0] + tmp[6]*src[1] + tmp[11]*src[3];
  dst[6] -= tmp[2]*src[0] + tmp[7]*src[1] + tmp[10]*src[3];
  dst[7]  = tmp[4]*src[0] + tmp[9]*src[1] + tmp[10]*src[2];
  dst[7] -= tmp[5]*src[0] + tmp[8]*src[1] + tmp[11]*src[2];
  /* calculate pairs for second 8 elements (cofactors) */
  tmp[0]  = src[2]*src[7];
  tmp[1]  = src[3]*src[6];
  tmp[2]  = src[1]*src[7];
  tmp[3]  = src[3]*src[5];
  tmp[4]  = src[1]*src[6];
  tmp[5]  = src[2]*src[5];
  tmp[6]  = src[0]*src[7];
  tmp[7]  = src[3]*src[4];
  tmp[8]  = src[0]*src[6];
  tmp[9]  = src[2]*src[4];
  tmp[10] = src[0]*src[5];
  tmp[11] = src[1]*src[4];
  /* calculate second 8 elements (cofactors) */
  dst[8]  = tmp[0]*src[13] + tmp[3]*src[14] + tmp[4]*src[15];
  dst[8] -= tmp[1]*src[13] + tmp[2]*src[14] + tmp[5]*src[15];
  dst[9]  = tmp[1]*src[12] + tmp[6]*src[14] + tmp[9]*src[15];
  dst[9] -= tmp[0]*src[12] + tmp[7]*src[14] + tmp[8]*src[15];
  dst[10] = tmp[2]*src[12] + tmp[7]*src[13] + tmp[10]*src[15];
  dst[10]-= tmp[3]*src[12] + tmp[6]*src[13] + tmp[11]*src[15];
  dst[11] = tmp[5]*src[12] + tmp[8]*src[13] + tmp[11]*src[14];
  dst[11]-= tmp[4]*src[12] + tmp[9]*src[13] + tmp[10]*src[14];
  dst[12] = tmp[2]*src[10] + tmp[5]*src[11] + tmp[1]*src[9];
  dst[12]-= tmp[4]*src[11] + tmp[0]*src[9] + tmp[3]*src[10];
  dst[13] = tmp[8]*src[11] + tmp[0]*src[8] + tmp[7]*src[10];
  dst[13]-= tmp[6]*src[10] + tmp[9]*src[11] + tmp[1]*src[8];
  dst[14] = tmp[6]*src[9] + tmp[11]*src[11] + tmp[3]*src[8];
  dst[14]-= tmp[10]*src[11] + tmp[2]*src[8] + tmp[7]*src[9];
  dst[15] = tmp[10]*src[10] + tmp[4]*src[8] + tmp[9]*src[9];
  dst[15]-= tmp[8]*src[9] + tmp[11]*src[10] + tmp[5]*src[8];
  
  /* calculate determinant */
  det = src[0]*dst[0] + src[1]*dst[1] + src[2]*dst[2] + src[3]*dst[3];
  
  /* calculate matrix inverse */
  det = 1/det;
  for int i <- 0..16
    mat[i] = dst[i] * det; // output
}

vec4f mat-multiply(float* matrix, vec4f v) {
  return vec4f(
    matrix[0 ]*v.x + matrix[4 ]*v.y + matrix[8 ]*v.z + matrix[12]*v.w,
    matrix[1 ]*v.x + matrix[5 ]*v.y + matrix[9 ]*v.z + matrix[13]*v.w,
    matrix[2 ]*v.x + matrix[6 ]*v.y + matrix[10]*v.z + matrix[14]*v.w,
    matrix[3 ]*v.x + matrix[7 ]*v.y + matrix[11]*v.z + matrix[15]*v.w
  );
}
