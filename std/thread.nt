/*Title: std.thread
Threading*/
module std.thread;

import c.pthread;

platform(*-mingw*) {
  pragma(lib, "pthreadGC2");
}

extern(C) {
  int pthread_create(pthread_t*, pthread_attr_t*,
                     void* function(void*), void*);
  int pthread_getattr_np(pthread_t, pthread_attr_t*);
  int pthread_attr_getstack(pthread_attr_t*, void**, size_t*);
}

void delegate(void*) onThreadCreation;

platform(default) {
  void* stack-base;
  int stack-size;
  void setupStackBase() {
    auto id = pthread_self();
    pthread_attr_t attr;
    id.pthread_getattr_np(&attr);
    pthread_attr_getstack(&attr, &stack-base, size_t*:&stack-size);
    stack-base = void*:(ubyte*:stack-base + stack-size);
  }
  void init() { setupStackBase; setupTLSSize(); }
}

platform(i686-mingw32) {
  void setupStackBase() {
    // writeln "setupStackBase() not implemented under win32! ";
  }
  void init() { setupTLSSize(); }
}

import c.semaphore;
/*Class: Semaphore
A Semaphore locking object. */
class Semaphore {
  sem_t hdl;
  /*Function: init*/
  void init() { sem_init(&hdl, false, 0); }
  import std.file, c.errno;
  /*Function: claim*/
  void claim() { while (sem_wait(&hdl) == -1) { if (errno == EINTR) continue; raise new ErrnoError("sem_wait"); } }
  /*Function: release*/
  void release() { while (sem_post(&hdl) == -1) { if (errno == EINTR) continue; raise new ErrnoError("sem_wait"); } }
}

vec4f aligntest_a, aligntest_b;

extern(C) void* __start_routine(void* p) {
  auto arg = *(void delegate(), void*, int, Semaphore, type-of mem)*:p;
  auto _threadlocal = arg[1];
  setThreadlocal _threadlocal;
  mxcsr = arg[2];
  mem = arg[4];
  setupStackBase;
  arg[3].release;
  dupvcache = null;
  if (onThreadCreation) {
    onThreadCreation(_ebp);
  }
  arg[0]();
  return null;
}

void startThread(void delegate() dg) {
  pthread_t buf;
  (void delegate(), void*, int, Semaphore, type-of mem) arg;
  arg[0] = dg;
  arg[1] = copy_tls;
  arg[2] = mxcsr;
  arg[3] = new Semaphore;
  arg[4] = mem;
  
  auto res = pthread_create(&buf, null, &__start_routine, &arg);
  arg[3].claim;
}

platform(default) {
  pragma(lib, "pthread");
  struct pthread_mutex_t { ubyte x 40  filler; }
  extern(C) int pthread_mutex_init (pthread_mutex_t*, void*);
  extern(C) int pthread_mutex_lock (pthread_mutex_t*);
  extern(C) int pthread_mutex_unlock (pthread_mutex_t*);
  struct pthread_rwlock_t { ubyte x 56  filler; }
  extern(C) {
    int pthread_rwlock_init(pthread_rwlock_t* rwlock, void* attr);
    int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock);
    int pthread_rwlock_wrlock(pthread_rwlock_t* rwlock);
    int pthread_rwlock_unlock(pthread_rwlock_t* rwlock);
  }
}

/*Class: Mutex
A Mutual Exclusion lock*/
class Mutex {
  pthread_mutex_t mutex;
  /*Function: init*/
  void init() { pthread_mutex_init (&mutex, null); }
  /*Function: lock*/
  void lock() { pthread_mutex_lock &mutex; }
  /*Function: unlock*/
  void unlock() { pthread_mutex_unlock &mutex; }
}

/*Class: ReadWriteLock
Can only be written by one thread
Can be read many times, but only while not being written*/
class ReadWriteLock {
  pthread_rwlock_t lock;
  /*Function: init*/
  void init() { pthread_rwlock_init(&lock, null); }
  /*Function: lock-read
  Lock for reading*/
  void lock-read() { pthread_rwlock_rdlock &lock; }
  /*Function: lock-write
  Lock for writing*/
  void lock-write() { pthread_rwlock_wrlock &lock; }
  /*Function: unlock*/
  void unlock() { pthread_rwlock_unlock &lock; }
}

struct LockedMutex {
  Mutex __m;
  void onUsing() __m.lock();
  void onExit() __m.unlock();
}

struct UnlockedMutex {
  Mutex __m;
  void onUsing() __m.unlock();
  void onExit() __m.lock();
}

template New(T) {
  void New(T t) {
    alias obj = *t;
    alias classtype = type-of obj;
    obj = new classtype;
  }
}

/*Class: ThreadPool
A classic thread pool. Keeps a queue of tasks to be executed on a first-come, first-serve basis. 
*/
class ThreadPool {
  Mutex m, readlock, writelock;
  Semaphore s, t;
  int tasksLeft, numThreads;
  void delegate(int)[] readqueue, readqueue-full;
  void delegate(int)[auto~] writequeue;
  /*Function: init*/
  void init() {
    New &readlock;
    New &writelock;
    New &m;
    New &s;
    New &t;
  }
  void threadFun(int id) {
    /*if (int:_ebp & 0xf != 0x8) {
      writeln "FEEEP! YOU BROKE THE FUCKING THREAD FRAME ALIGNMENT AGAIN. $(_ebp) ";
      *int*:null=0;
    }*/
    while (true) {
      s.claim;
      void delegate(int) dg;
      using LockedMutex:readlock {
        if (!readqueue.length) {
          readqueue-full.free;
          using LockedMutex:writelock {
            readqueue = writequeue[];
            readqueue-full = readqueue;
            writequeue = type-of writequeue: type-of readqueue: null;
          }
        }
        (dg, readqueue) = readqueue[(0, 1..$)];
      }
      set-handler (UnrecoverableError err) {
        // gdb-print-backtrace;
        import std.process;
        writeln read-pretty-fcc-backtrace();
        writeln "Unhandled error in task: '$err'. ";
        
        invoke-exit "task-continue";
      }
      define-exit "task-continue" continue;
      onExit t.release();
      dg(id);
    }
  }
  /*Function: addThread
  Starts a new thread and adds it to the pool*/
  void addThread() {
    int thr-id = numThreads ++;
    auto tf = &threadFun;
    startThread new delegate void() { tf(thr-id); };
  }
  /*Function: init
  Starts *i* threads*/
  void init(int i) {
    init();
    for (0..i) addThread();
  }
  /*Function: waitComplete
  Wait until all tasks have been completed. */
  void waitComplete() {
    using LockedMutex:m {
      while (tasksLeft) { 
        this.m.unlock;
        t.claim;
        this.m.lock;
        tasksLeft --;
      }
    }
  }
  /*Function: addTask
  Adds a task to be executed. The task is called with the id of the thread that's executing it. */
  void addTask(void delegate(int) dg) {
    if (!numThreads) { dg(0); return; }
    using LockedMutex:m tasksLeft ++;
    using LockedMutex:writelock writequeue ~= dg;
    s.release;
  }
  /*Function: addTask
  Adds a task to be executed. */
  void addTask(void delegate() dg) {
    if (!numThreads) { dg(); return; }
    addTask new delegate void(int) { dg(); };
  }
}

/*Class: LoopPool
A thread pool optimized for executing a large number of homogenous tasks.
*/
class LoopPool {
  Semaphore s, t, u;
  int numThreads;
  int runningId, maxId;
  void delegate(int id, int thr) dg;
  Mutex m;
  /*Function: init*/
  void init() {
    New &s;
    New &t;
    New &u;
    New &m;
  }
  /*Function: init
  Starts *i* threads*/
  void init(int i) {
    init();
    for 0..i addThread();
  }
  void threadFun(int thr-id) {
    { auto tmp = aligntest_b; aligntest_a = tmp; }
    while true {
      s.claim;
      int myId;
      do using LockedMutex:m myId = runningId ++;
      while (myId < maxId) dg(myId, thr-id);
      t.release;
      u.claim;
    }
  }
  /*Function: addThread
  Starts a new thread and adds it to the pool*/
  void addThread() {
    int thr-id = numThreads ++;
    auto tf = &threadFun;
    startThread new delegate void() { tf(thr-id); };
  }
  /*Function: runLoop
  Runs *to* tasks in parallel, each calling *dg* with the task number and the thread index. */
  void runLoop(int to, void delegate(int, int) dg) {
    this.dg = dg;
    runningId = 0;
    maxId = to;
    for 0 .. numThreads s.release;
    for 0 .. numThreads t.claim;
    for 0 .. numThreads u.release;
  }
}
