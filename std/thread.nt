module std.thread;

import c.pthread;

extern(C) {
  int pthread_create(pthread_t*, pthread_attr_t*,
                     void* function(void*), void*);
  int pthread_getattr_np(pthread_t, pthread_attr_t*);
  int pthread_attr_getstack(pthread_attr_t*, void**, size_t*);
}

void delegate() onThreadCreation;

void* stack-base;
int stack-size;
void setupStackBase() {
  auto id = pthread_self();
  pthread_attr_t attr;
  id.pthread_getattr_np(&attr);
  pthread_attr_getstack(&attr, &stack-base, size_t*:&stack-size);
  stack-base = void*:(byte*:stack-base + stack-size);
}

void init() setupStackBase;

shared int tls_size;

import c.semaphore;
class Semaphore {
  sem_t hdl;
  void init() { sem_init(&hdl, false, 0); }
  void claim() { sem_wait(&hdl); }
  void release() { sem_post(&hdl); }
}

void* __start_routine(void* p) {
  void* ptemp = p; // will be top of the stack, so ..
  asm "popl %eax";
  asm "movl %esp, %ebx";
  asm `andl $0xfffffff0, %esp`;
  asm `subl $8, %esp`; // alignment
  asm "pushl %ebx";
  asm "pushl %ebp";
  asm "pushl %eax";
  asm "movl %esp, %ebp";
  asm `addl $4, %ebp`;
  {
    auto arg = *(void delegate(), void*, int, Semaphore)*:ptemp;
    arg[3].release;
    _esi = arg[1];
    mxcsr = arg[2];
    setupStackBase;
    if (onThreadCreation)
      onThreadCreation();
    arg[0]();
  }
  // and undo
  asm `addl $4, %esp`; // undo pushl %eax
  asm "popl %ebp";
  asm "popl %ebx";
  asm "movl %ebx, %esp";
  asm `pushl $0`; // undo popl %eax; pointer not needed anymore.
  return null;
}

extern(C) int _sys_tls_data_start;
void startThread(void delegate() dg) {
  pthread_t buf;
  (void delegate(), void*, int, Semaphore) arg;
  arg[0] = dg;
  int dataStart = 0x7fffffff, dataEnd;
  auto
    localStart = [for mod <- __modules: int:mod.dataStart - int:&_sys_tls_data_start],
    localEnd = [for mod <- __modules: int:mod.dataEnd - int:&_sys_tls_data_start],
    localRange = zip(localStart, localEnd);
  for (auto tup <- zip(__modules, localRange)) {
    alias mod = tup[0], range = tup[1];
    if (mod.compiled) {
      if (range[0] < dataStart) dataStart = range[0];
      if (range[1] > dataEnd) dataEnd = range[1];
    }
  }
  alias dataSize = dataEnd - dataStart; tls_size = dataSize;
  auto oldArea = _esi[dataStart..dataEnd];
  auto newArea = (sys.malloc(dataSize) - dataStart)[0 .. dataEnd];
  for (auto range <- localRange) {
    newArea[range[0] .. range[1]] = _esi[range[0] .. range[1]];
  }
  arg[1] = newArea.ptr;
  arg[2] = mxcsr;
  arg[3] = new Semaphore;
  
  pthread_create(&buf, null, &__start_routine, &arg);
  arg[3].claim;
}

platform(default) <<EOF
  pragma(lib, "pthread");
  struct pthread_mutex_t { ubyte x 40  filler; }
  extern(C) int pthread_mutex_init (pthread_mutex_t*, void*);
  extern(C) int pthread_mutex_lock (pthread_mutex_t*);
  extern(C) int pthread_mutex_unlock (pthread_mutex_t*);
  struct pthread_rwlock_t { ubyte x 56  filler; }
  extern(C) {
    int pthread_rwlock_init(pthread_rwlock_t* rwlock, void* attr);
    int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock);
    int pthread_rwlock_wrlock(pthread_rwlock_t* rwlock);
    int pthread_rwlock_unlock(pthread_rwlock_t* rwlock);
  }
EOF

class Mutex {
  pthread_mutex_t mutex;
  void init() { pthread_mutex_init (&mutex, null); }
  void lock() { pthread_mutex_lock &mutex; }
  void unlock() { pthread_mutex_unlock &mutex; }
}

class ReadWriteLock {
  pthread_rwlock_t lock;
  void init() { pthread_rwlock_init(&lock, null); }
  void lock-read() { pthread_rwlock_rdlock &lock; }
  void lock-write() { pthread_rwlock_wrlock &lock; }
  void unlock() { pthread_rwlock_unlock &lock; }
}

struct MutexWrapper {
  Mutex m;
  void onUsing() { m.lock(); }
  void onExit() { m.unlock(); }
}

MutexWrapper autoLock(Mutex m) { MutexWrapper mw; mw.m = m; return mw; }

template New(T) <<EOF
  void New(T t) {
    alias obj = *t;
    alias classtype = type-of obj;
    obj = new classtype;
  }
EOF

class ThreadPool {
  Mutex m, readlock, writelock;
  Semaphore s, t;
  int tasksLeft, numThreads;
  void delegate(int)[] readqueue, readqueue-full;
  void delegate(int)[auto~] writequeue;
  void init() {
    New &readlock;
    New &writelock;
    New &m;
    New &s;
    New &t;
  }
  void threadFun(int id) {
    if (int:_ebp & 0xf) {
      writeln "FEEEP! YOU BROKE THE FUCKING THREAD FRAME ALIGNMENT AGAIN. $(_ebp) ";
      _interrupt 3;
    }
    while (true) {
      s.claim;
      void delegate(int) dg;
      using autoLock readlock {
        if (!readqueue.length) {
          readqueue-full.free;
          using autoLock writelock {
            readqueue = writequeue[];
            readqueue-full = readqueue;
            writequeue = type-of writequeue: type-of readqueue: null;
          }
        }
        (dg, readqueue) = readqueue[(0, 1..$)];
      }
      dg(id);
      t.release();
    }
  }
  void addThread() {
    int thr-id = numThreads ++;
    auto tf = &threadFun;
    startThread new delegate void() { tf(thr-id); };
  }
  void init(int i) {
    init();
    for (0..i) addThread();
  }
  void waitComplete() {
    int i;
    using autoLock(m) { i = tasksLeft; tasksLeft = 0; }
    while 0..i t.claim();
  }
  void addTask(void delegate(int) dg) {
    using autoLock(m) tasksLeft ++;
    using autoLock writelock writequeue ~= dg;
    s.release;
  }
  void addTask(void delegate() dg) {
    addTask new delegate void(int) { dg(); };
  }
}

class LoopPool {
  Semaphore s, t;
  int numThreads;
  int runningId;
  void delegate(int id, int thr) dg;
  Mutex m;
  void init() {
    New &s;
    New &t;
    New &m;
  }
  void threadFun(int thr-id) {
    while true {
      s.claim;
      int myId;
      using autoLock m myId = runningId++;
      dg(myId, thr-id);
      t.release;
    }
  }
  void addThread() {
    int thr-id = numThreads ++;
    auto tf = &threadFun;
    startThread new delegate void() { tf(thr-id); };
  }
  void init(int i) {
    init();
    for 0..i addThread();
  }
  void runLoop(int to, void delegate(int, int) dg) {
    using autoLock m {
      this.dg = dg;
      runningId = 0;
    }
    for 0..to s.release;
    for 0..to t.claim;
  }
}
