module std.sound.threaded; // separate playback thread

import std.sound.base, std.thread, std.time, std.list;

class ThreadedOutput : SoundOutput {
  ThreadPool tp;
  SoundOutput sup;
  int maxOutstandingSamples;
  void init(SoundOutput sup) {
    tp = new ThreadPool 1;
    this.sup = sup;
    maxOutstandingSamples = 32768;
    m = new Mutex;
    gotNewData = new Semaphore;
    tp.addTask &playBuffer;
  }
  void wait() sleep(0.01);
  void playBuffer() {
    using LockedMutex:m {
      if (!buffer.hasData) using UnlockedMutex:m gotNewData.claim(); // initial data
      while (buffer.hasData /* true */) {
        scope data = buffer.popTail();
        bufferlen -= data.length;
        // the next time we go to add data, we'll release the semaphore
        // so we need to collect that token before looping
        bool wasEmptied = !bufferlen;
        // writeln "dump $(data.length), left $(bufferlen)";
        using UnlockedMutex:m sup.dump data;
        if (wasEmptied) using UnlockedMutex:m gotNewData.claim();
      }
      fail;
    }
  }
  DoubleLinkedList!(Sample[]) buffer;
  int bufferlen;
  Mutex m;
  Semaphore gotNewData;
  void block() {
    using LockedMutex:m {
      while (bufferlen) using UnlockedMutex:m wait;
    }
  }
  override {
    void open() sup.open;
    void close() { block; sup.close; }
    void writeCopydump(int len) {
      if (!len) return;
      auto copy = copydump[0..len].dup;
      using LockedMutex:m {
        if (!buffer.hasData) gotNewData.release();
        buffer.pushHead copy;
        bufferlen += len;
        while (bufferlen > maxOutstandingSamples)
          using UnlockedMutex:m wait;
      }
    }
  }
}
