module std.coroutine; // coroutines. TODO: make play nice with boehm by explicitly registering stack on leaving

import std.file, c.ucontext, c.sys.mman;

extern(C) void makecontext(ucontext_t* ucp, void function() func, int argc, ...);

void call(void delegate() dg, void* threadlocal) {
  _threadlocal = threadlocal;
  dg();
}

class Coroutine {
  void[] stack;
  ucontext_t ctx;
  void delegate() leave;
  void delegate(void delegate() yield) task;
  void exit() { leave(); }
  void run() {
    task(&exit);
    raise new Error "Coroutine invoked but task has returned. ";
  }
  void init(void delegate(void delegate() yield) task, int stacksize = 1024*1024) {
    this.task = task;
    assert(!!task);
    auto ptr = mmap(null, stacksize, PROT_READ|PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_STACK, -1, 0);
    if (!ptr) raise new ErrnoError;
    stack = ptr[0..stacksize];
    if (getcontext(&ctx) == -1) raise new ErrnoError;
    ctx.uc_stack.(ss_sp, ss_size, ss_flags) = (stack.ptr, stacksize, 0);
    makecontext(&ctx, void function(): &call, size-of (void delegate(), void*)/size-of int, &run, _threadlocal);
  }
  void enter() {
    ucontext_t prev;
    leave = \{
      if (swapcontext(&ctx, &prev) == -1) raise new ErrnoError;
    }
    if (swapcontext(&prev, &ctx) == -1) raise new ErrnoError;
  }
}

template setupCoIterator(T) {
  Iterator!T setupCoIterator(void delegate(void delegate(T)) dg) {
    ref res = * T*: mem.malloc size-of T, done = *new bool;
    auto coro = new Coroutine new \(void delegate() yield) {
      dg \(T t) { res = t; yield(); };
      done = true;
      yield(); fail;
    };
    return new class : Iterator!T {
      T* rp; bool* dp; Coroutine coro;
      alias res = *rp; alias done = *dp;
      void init(T* rp, bool* dp, Coroutine coro) { this.(rp, dp, coro) = (rp, dp, coro); }
      bool advance() {
        if (done) return false;
        coro.enter();
        if (done) return false;
        value = res;
        return true;
      }
    } (&res, &done, coro);
  }
}
