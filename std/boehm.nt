module std.boehm; // use Boehm GC

import c.gc, std.thread;

pragma(lib, "gc");

void* myDebugRealloc(void* a, size_t b) { return GC_debug_realloc(a, int:b, "", 0); }
void* myDebugMalloc(int a) { return GC_debug_malloc(int:a, "", 0); }
void* myDebugCalloc(int a, b) { return myDebugMalloc(a * b); }

void* myRealloc(void* a, size_t b) { return GC_realloc(a, int:b); }
void* myMalloc(int a) { return GC_malloc(int:a); }
void* myCalloc(int a, b) {
  auto len = a * b;
  auto res = myMalloc(len);
  auto bp = byte*:res;
  for 0..len { *(bp++) = byte:0; }
  return res;
}

platform(default) <<EOF
  void register_thread(void* stackbase /* ignored for known thread base */) {
    GC_stack_base gsb;
    gsb.mem_base = stack-base;
    GC_register_my_thread(&gsb);
    // writeln "register stack base $(stack-base) (ebp $(_ebp))";
    // register my TLS segment as a root
    GC_add_roots(_esi, _esi + tls_size);
  }
EOF

platform(i686-mingw32) <<EOF
  void register_thread(void* stackbase) {
    GC_stack_base gsb;
    if (!stackbase)
      raise-error new Error "Must supply stackbase for Boehm under Windows! ";
    gsb.mem_base = stackbase;
    GC_register_my_thread(&gsb);
    GC_add_roots(_esi, _esi + tls_size);
  }
EOF

void initBoehm(bool debugMode = false) {
  (mem.malloc_dg, mem.calloc_dg, mem.realloc_dg, mem.free_dg)
    = [(&myMalloc,      &myCalloc,      &myRealloc,      &GC_free),
       (&myDebugMalloc, &myDebugCalloc, &myDebugRealloc, &GC_debug_free)
      ][debugMode];
  GC_init;
  GC_allow_register_threads;
  GC_add_roots(_esi, _esi + tls_size); // remind me why I need to do this
  auto oldDg = onThreadCreation;
  onThreadCreation = new delegate void(void* stackbase) {
    if (oldDg) { oldDg(stackbase); }
    register_thread(stackbase);
  };
}
