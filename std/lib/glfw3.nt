module std.lib.glfw3;

public import c.GL.glfw3;

import std.lib.opengl; // enforce library ordering

pragma(lib, "glfw");

defmode GLFW "prefix GLFW_ prefix glfw";

void delegate(GLFWwindow, int, int) windowSizeCallback;
void delegate(GLFWwindow, int, int) keyCallback;
void delegate(GLFWwindow, int) charCallback;
void delegate(GLFWwindow, int, int) mousePosCallback;
void delegate(GLFWwindow, int, int) mouseButtonCallback;

extern(C) {
  void WindowSizeCallback(GLFWwindow wnd, int w, h) {
    _esi = glfwGetWindowUserPointer(wnd);
    windowSizeCallback?(wnd, w, h);
  }
  void KeyCallback(GLFWwindow wnd, int k, action) {
    _esi = glfwGetWindowUserPointer(wnd);
    keyCallback?(wnd, k, action);
  }
  void CharCallback(GLFWwindow wnd, int k) {
    _esi = glfwGetWindowUserPointer(wnd);
    charCallback?(wnd, k);
  }
  void MousePosCallback(GLFWwindow wnd, int x, y) {
    _esi = glfwGetWindowUserPointer(wnd);
    mousePosCallback?(wnd, x, y);
  }
  void MouseButtonCallback(GLFWwindow wnd, int a, b) {
    _esi = glfwGetWindowUserPointer(wnd);
    mouseButtonCallback?(wnd, a, b);
  }
}

void initCallbacks() using mode GLFW {
  SetWindowSizeCallback &WindowSizeCallback;
  SetKeyCallback &KeyCallback;
  SetCharCallback &CharCallback;
  SetMousePosCallback &MousePosCallback;
  SetMouseButtonCallback &MouseButtonCallback;
}

import std.lib.opengl.window;

class GLFWWindow : GLWindow {
  GLFWwindow handle;
  int w, h;
  vec2i size() { return vec2i(w, h); }
  void key(GLFWwindow window, int k, int action) {
    if (window != handle) raise new Error "wat";
    // writeln "$k with $action";
    void set(Key code) {
      if (key-held.length < code + 1) key-held ~= new bool[] code + 1 - key-held.length;
      if (key-pressed.length < code + 1) key-pressed ~= new bool[] code + 1 - key-pressed.length;
      if (key-released.length < code + 1) key-released ~= new bool[] code + 1 - key-released.length;
      
      if (action == GLFW_PRESS) {
        key-held[code] = true;
        key-pressed[code] = true;
      } else {
        key-held[code] = false;
        key-released[code] = true;
      }
    }
    
    if (GLFW_KEY_A <= k <= GLFW_KEY_Z)
      set Key:$ Key.A + k - GLFW_KEY_A;
    
    import std.macros.switchover;
    switch int i over i == k {
      case GLFW_KEY_RIGHT: set Key.RightArrow;
      case GLFW_KEY_LEFT : set Key.LeftArrow;
      case GLFW_KEY_DOWN : set Key.DownArrow;
      case GLFW_KEY_UP   : set Key.UpArrow;
    }
  }
  void handleChar(GLFWwindow window, int k) {
    if (window != handle) raise new Error "wat";
    auto ch = char:byte:k;
    auto asUTF8 = &ch #[0..1]; // THIS IS SO WRONG. TODO fix.
    onTextInput.call asUTF8;
  }
  void reshape(GLFWwindow window, int width, height) {
    if (window != handle) raise new Error "wat";
    (w, h) = (width, height);
    glViewport(0, 0, width, height);
  }
  void mousepos(GLFWwindow window, int x, y) {
    if (window != handle) raise new Error "wat";
    mouse-pos = vec2i(x, y);
  }
  void mousebutton(GLFWwindow window, int button, action) {
    if (window != handle) raise new Error "wat";
    if (button == 0) {
      if (action) mouse-clicked = true;
      else mouse-released = true;
    } else if (button == 1) {
      if (action) right-mouse-clicked = true;
      else right-mouse-released = true;
    }
  }
  bool is-set-up;
  string title;
  void setup() using mode GLFW {
    if (!Init()) raise new Error "Failed to init GLFW";
    onFailure Terminate;
    
    OpenWindowHint(DEPTH_BITS, 16);
    (w, h) = (640, 480);
    if (!title) title = "GLFW Window";
    import std.string;
    handle = OpenWindow (w, h, WINDOWED, toStringz title, null);
    if (!handle) raise new Error "Failed to open GLFW window";
    
    handle.SetWindowUserPointer (_esi);
    
    handle.SetInputMode (KEY_REPEAT, true);
    // SwapInterval 0;
    
    windowSizeCallback = &reshape;
    keyCallback = &key;
    charCallback = &handleChar;
    mousePosCallback = &mousepos;
    mouseButtonCallback = &mousebutton;
    initCallbacks();
    is-set-up = true;
    for (auto dg <- context-callbacks) dg();
  }
  bool isSetUp() { return is-set-up; }
  void update() using mode GLFW {
    mouse-clicked = false;
    mouse-released = false;
    right-mouse-clicked = false;
    right-mouse-released = false;
    key-pressed[] = [for key-pressed: false];
    key-released[] = [for key-released: false];
    SwapBuffers;
    PollEvents;
    if (!IsWindow(handle)) raise new WindowClosed "GLFW exit";
  }
  bool claimed;
  void claim-cursor() using mode GLFW {
    handle.SetInputMode(CURSOR_MODE, CURSOR_CAPTURED);
    warp $ size() / 2;
    claimed = true;
  }
  void warp(vec2i to) using mode GLFW {
    handle.SetMousePos to;
    mouse-pos = to;
  }
  void release-cursor() using mode GLFW {
    handle.SetInputMode(CURSOR_MODE, CURSOR_NORMAL);
    claimed = false;
  }
  bool cursor-claimed() { return claimed; }
}
