module std.lib.glfw3;

public import c.GL.glfw3;

import std.lib.opengl; // enforce library ordering

pragma(lib, "glfw");

defmode GLFW "prefix GLFW_ prefix glfw";

void delegate(GLFWwindow, int, int) windowSizeCallback;
void delegate(GLFWwindow, int, int) keyCallback;
void delegate(GLFWwindow, int) charCallback;
void delegate(GLFWwindow, int, int) cursorPosCallback;
void delegate(GLFWwindow, int, int) mouseButtonCallback;
void delegate(GLFWwindow, double, double) scrollCallback;
int delegate(GLFWwindow) windowCloseCallback;

extern(C) {
  void WindowSizeCallback(GLFWwindow wnd, int w, h) {
    _esi = glfwGetWindowUserPointer(wnd);
    windowSizeCallback?(wnd, w, h);
  }
  void KeyCallback(GLFWwindow wnd, int k, action) {
    _esi = glfwGetWindowUserPointer(wnd);
    keyCallback?(wnd, k, action);
  }
  void CharCallback(GLFWwindow wnd, int k) {
    _esi = glfwGetWindowUserPointer(wnd);
    charCallback?(wnd, k);
  }
  void CursorPosCallback(GLFWwindow wnd, int x, y) {
    _esi = glfwGetWindowUserPointer(wnd);
    cursorPosCallback?(wnd, x, y);
  }
  void MouseButtonCallback(GLFWwindow wnd, int a, b) {
    _esi = glfwGetWindowUserPointer(wnd);
    mouseButtonCallback?(wnd, a, b);
  }
  void ScrollCallback(GLFWwindow wnd, double x, y) {
    _esi = glfwGetWindowUserPointer(wnd);
    scrollCallback?(wnd, x, y);
  }
  int WindowCloseCallback(GLFWwindow wnd) {
    _esi = glfwGetWindowUserPointer(wnd);
    return windowCloseCallback?(wnd);
  }
}

void initCallbacks() using mode GLFW {
  SetWindowSizeCallback &WindowSizeCallback;
  SetKeyCallback &KeyCallback;
  SetCharCallback &CharCallback;
  SetCursorPosCallback &CursorPosCallback;
  SetMouseButtonCallback &MouseButtonCallback;
  SetScrollCallback &ScrollCallback;
  SetWindowCloseCallback &WindowCloseCallback;
}

import std.lib.opengl.window;

class GLFWError : Error {
  void init(string s) using mode GLFW {
    auto num = GetError();
    import std.string;
    auto text = CToString ErrorString num;
    super.init "GLFWError: $s: $num($text)";
  }
}

class GLFWWindow : GLWindow {
  GLFWwindow handle;
  int w, h;
  vec2i size() { return vec2i(w, h); }
  void key(GLFWwindow window, int k, int action) {
    if (window != handle) raise new Error "wat";
    // writeln "$k with $action";
    void set(Key code) {
      if (key-held.length < code + 1) key-held ~= new bool[] code + 1 - key-held.length;
      if (key-pressed.length < code + 1) key-pressed ~= new bool[] code + 1 - key-pressed.length;
      if (key-released.length < code + 1) key-released ~= new bool[] code + 1 - key-released.length;
      
      if (action == GLFW_PRESS) {
        key-held[code] = true;
        key-pressed[code] = true;
      } else {
        key-held[code] = false;
        key-released[code] = true;
      }
    }
    
    if (GLFW_KEY_A <= k <= GLFW_KEY_Z)
      set Key:$ Key.A + k - GLFW_KEY_A;
    
    import std.macros.switchover;
    using Key using prefix GLFW_KEY_ switch int i over i == k {
      case ENTER: set Return;
      case RIGHT: set RightArrow;
      case LEFT : set LeftArrow;
      case DOWN : set DownArrow;
      case UP   : set UpArrow;
      case INSERT : set Insert;
      case HOME   : set Home;
      case PAGE_UP: set PageUp;
      case DELETE : set Delete;
      case END    : set End;
      case PAGE_DOWN: set PageDown;
      case BACKSPACE: set Backspace;
      case LSHIFT   : set LeftShift;
      case RSHIFT   : set RightShift;
      case LCTRL    : set LeftControl;
      case RCTRL    : set RightControl;
      case ESC  : set Escape;
      case PAUSE: set Pause;
      case GLFW_KEY_F1..GLFW_KEY_F12: set Key:(Key.F1 + k - GLFW_KEY_F1);
    }
  }
  string queuedInput;
  void handleChar(GLFWwindow window, int k) {
    if (window != handle) raise new Error "wat";
    auto ch = char:byte:k;
    auto asUTF8 = &ch #[0..1]; // THIS IS SO WRONG. TODO fix.
    // don't callback yet; we're called from C so we can't trust the alignment
    queuedInput ~= asUTF8;
  }
  void reshape(GLFWwindow window, int width, height) {
    if (window != handle) raise new Error "wat";
    (w, h) = (width, height);
    glViewport(0, 0, width, height);
  }
  void mousepos(GLFWwindow window, int x, y) {
    if (window != handle) raise new Error "wat";
    mouse-pos = vec2i(x, y);
  }
  void mousebutton(GLFWwindow window, int button, action) {
    if (window != handle) raise new Error "wat";
    if (action) buttons[button].(clicked, pressed) = (true, true);
    else buttons[button].(released, pressed) = (true, false);
  }
  void scroll(GLFWwindow window, double x, y) {
    scroll-state += vec2i(int:x, int:y);
  }
  int closedfn(GLFWwindow window) { closed = true; return true; }
  bool is-set-up, closed;
  string title;
  void setTitle(string s) {
    import std.string;
    handle.glfwSetWindowTitle(auto ptr = toStringz s);
    mem.free ptr;
  }
  void setup(vec2i size) using mode GLFW {
    if (!Init()) raise new GLFWError "Failed to init GLFW";
    onFailure Terminate;
    
    WindowHint(DEPTH_BITS, 16);
    (w, h) = size;
    if (!title) title = "GLFW Window";

    windowSizeCallback = &reshape;
    keyCallback = &key;
    charCallback = &handleChar;
    cursorPosCallback = &mousepos;
    mouseButtonCallback = &mousebutton;
    scrollCallback = &scroll;
    windowCloseCallback = &closedfn;
    initCallbacks();
    
    import std.string;
    handle = CreateWindow (w, h, WINDOWED, toStringz title, null);
    if (!handle) raise new GLFWError "Failed to open GLFW window";
    MakeContextCurrent handle;
    
    handle.SetWindowUserPointer (_esi);
    
    handle.SetInputMode (KEY_REPEAT, true);
    // SwapInterval 0;
    
    is-set-up = true;
    for (auto dg <- context-callbacks) dg();
  }
  bool isSetUp() { return is-set-up; }
  void update() using mode GLFW {
    for ref button <- buttons {
      button.(clicked, released) = (false, false);
    }
    key-pressed[] = [for key-pressed: false];
    key-released[] = [for key-released: false];
    scroll-state = vec2i 0;
    SwapBuffers handle;
    PollEvents;
    if (queuedInput) onTextInput.call queuedInput;
    queuedInput = null;
    if (closed) raise new WindowClosed "GLFW exit";
    // if (!IsWindow(handle)) raise new WindowClosed "GLFW exit";
  }
  void close() using mode GLFW {
    // handle.CloseWindow();
    writeln "TODO";
  }
  void warp(vec2i to) using mode GLFW {
    handle.SetCursorPos to;
    mouse-pos = to;
  }
  bool claimed;
  vec2i prev-pos;
  void claim-cursor() using mode GLFW {
    prev-pos = mouse-pos;
    handle.SetInputMode(CURSOR_MODE, CURSOR_CAPTURED);
    warp $ size() / 2;
    claimed = true;
  }
  void release-cursor() using mode GLFW {
    handle.SetInputMode(CURSOR_MODE, CURSOR_NORMAL);
    warp $ prev-pos;
    claimed = false;
  }
  bool cursor-claimed() { return claimed; }
}
