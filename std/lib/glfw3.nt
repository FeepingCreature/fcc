module std.lib.glfw3;

public import c.GL.glfw3;

import std.lib.opengl; // enforce library ordering

pragma(lib, "glfw");

defmode GLFW "prefix GLFW_ prefix glfw";

void delegate(GLFWwindow, int, int) windowSizeCallback;
void delegate(GLFWwindow, int, int) keyCallback;
void delegate(GLFWwindow, int) charCallback;
void delegate(GLFWwindow, int, int) mousePosCallback;
void delegate(GLFWwindow, int, int) mouseButtonCallback;
void delegate(GLFWwindow, int, int) scrollCallback;

extern(C) {
  void WindowSizeCallback(GLFWwindow wnd, int w, h) {
    _esi = glfwGetWindowUserPointer(wnd);
    windowSizeCallback?(wnd, w, h);
  }
  void KeyCallback(GLFWwindow wnd, int k, action) {
    _esi = glfwGetWindowUserPointer(wnd);
    keyCallback?(wnd, k, action);
  }
  void CharCallback(GLFWwindow wnd, int k) {
    _esi = glfwGetWindowUserPointer(wnd);
    charCallback?(wnd, k);
  }
  void MousePosCallback(GLFWwindow wnd, int x, y) {
    _esi = glfwGetWindowUserPointer(wnd);
    mousePosCallback?(wnd, x, y);
  }
  void MouseButtonCallback(GLFWwindow wnd, int a, b) {
    _esi = glfwGetWindowUserPointer(wnd);
    mouseButtonCallback?(wnd, a, b);
  }
  void ScrollCallback(GLFWwindow wnd, int x, y) {
    _esi = glfwGetWindowUserPointer(wnd);
    scrollCallback?(wnd, x, y);
  }
}

void initCallbacks() using mode GLFW {
  SetWindowSizeCallback &WindowSizeCallback;
  SetKeyCallback &KeyCallback;
  SetCharCallback &CharCallback;
  SetMousePosCallback &MousePosCallback;
  SetMouseButtonCallback &MouseButtonCallback;
  SetScrollCallback &ScrollCallback;
}

import std.lib.opengl.window;

class GLFWWindow : GLWindow {
  GLFWwindow handle;
  int w, h;
  vec2i size() { return vec2i(w, h); }
  void key(GLFWwindow window, int k, int action) {
    if (window != handle) raise new Error "wat";
    // writeln "$k with $action";
    void set(Key code) {
      if (key-held.length < code + 1) key-held ~= new bool[] code + 1 - key-held.length;
      if (key-pressed.length < code + 1) key-pressed ~= new bool[] code + 1 - key-pressed.length;
      if (key-released.length < code + 1) key-released ~= new bool[] code + 1 - key-released.length;
      
      if (action == GLFW_PRESS) {
        key-held[code] = true;
        key-pressed[code] = true;
      } else {
        key-held[code] = false;
        key-released[code] = true;
      }
    }
    
    if (GLFW_KEY_A <= k <= GLFW_KEY_Z)
      set Key:$ Key.A + k - GLFW_KEY_A;
    
    import std.macros.switchover;
    switch int i over i == k {
      case GLFW_KEY_ENTER: set Key.Return;
      case GLFW_KEY_RIGHT: set Key.RightArrow;
      case GLFW_KEY_LEFT : set Key.LeftArrow;
      case GLFW_KEY_DOWN : set Key.DownArrow;
      case GLFW_KEY_UP   : set Key.UpArrow;
      case GLFW_KEY_INSERT : set Key.Insert;
      case GLFW_KEY_HOME   : set Key.Home;
      case GLFW_KEY_PAGE_UP: set Key.PageUp;
      case GLFW_KEY_DELETE : set Key.Delete;
      case GLFW_KEY_END    : set Key.End;
      case GLFW_KEY_PAGE_DOWN: set Key.PageDown;
      case GLFW_KEY_BACKSPACE: set Key.Backspace;
      case GLFW_KEY_LSHIFT: set Key.LeftShift;
      case GLFW_KEY_RSHIFT: set Key.RightShift;
      case GLFW_KEY_LCTRL: set Key.LeftControl;
      case GLFW_KEY_RCTRL: set Key.RightControl;
    }
  }
  string queuedInput;
  void handleChar(GLFWwindow window, int k) {
    if (window != handle) raise new Error "wat";
    auto ch = char:byte:k;
    auto asUTF8 = &ch #[0..1]; // THIS IS SO WRONG. TODO fix.
    // don't callback yet; we're called from C so we can't trust the alignment
    queuedInput ~= asUTF8;
  }
  void reshape(GLFWwindow window, int width, height) {
    if (window != handle) raise new Error "wat";
    (w, h) = (width, height);
    glViewport(0, 0, width, height);
  }
  void mousepos(GLFWwindow window, int x, y) {
    if (window != handle) raise new Error "wat";
    mouse-pos = vec2i(x, y);
  }
  void mousebutton(GLFWwindow window, int button, action) {
    if (window != handle) raise new Error "wat";
    if (action) buttons[button].(clicked, pressed) = (true, true);
    else buttons[button].(released, pressed) = (true, false);
  }
  void scroll(GLFWwindow window, int x, y) {
    scroll-state += vec2i(x, y);
  }
  bool is-set-up;
  string title;
  void setTitle(string s) {
    import std.string;
    handle.glfwSetWindowTitle(auto ptr = toStringz s);
    mem.free ptr;
  }
  void setup(vec2i size) using mode GLFW {
    if (!Init()) raise new Error "Failed to init GLFW";
    onFailure Terminate;
    
    OpenWindowHint(DEPTH_BITS, 16);
    (w, h) = size;
    if (!title) title = "GLFW Window";
    import std.string;
    handle = OpenWindow (w, h, WINDOWED, toStringz title, null);
    if (!handle) raise new Error "Failed to open GLFW window";
    
    handle.SetWindowUserPointer (_esi);
    
    handle.SetInputMode (KEY_REPEAT, true);
    // SwapInterval 0;
    
    windowSizeCallback = &reshape;
    keyCallback = &key;
    charCallback = &handleChar;
    mousePosCallback = &mousepos;
    mouseButtonCallback = &mousebutton;
    scrollCallback = &scroll;
    initCallbacks();
    is-set-up = true;
    for (auto dg <- context-callbacks) dg();
  }
  bool isSetUp() { return is-set-up; }
  void update() using mode GLFW {
    for ref button <- buttons {
      button.(clicked, released) = (false, false);
    }
    key-pressed[] = [for key-pressed: false];
    key-released[] = [for key-released: false];
    scroll-state = vec2i 0;
    SwapBuffers;
    PollEvents;
    if (queuedInput) onTextInput.call queuedInput;
    queuedInput = null;
    if (!IsWindow(handle)) raise new WindowClosed "GLFW exit";
  }
  void warp(vec2i to) using mode GLFW {
    handle.SetMousePos to;
    mouse-pos = to;
  }
  bool claimed;
  vec2i prev-pos;
  void claim-cursor() using mode GLFW {
    prev-pos = mouse-pos;
    handle.SetInputMode(CURSOR_MODE, CURSOR_CAPTURED);
    warp $ size() / 2;
    claimed = true;
  }
  void release-cursor() using mode GLFW {
    handle.SetInputMode(CURSOR_MODE, CURSOR_NORMAL);
    warp $ prev-pos;
    claimed = false;
  }
  bool cursor-claimed() { return claimed; }
}
