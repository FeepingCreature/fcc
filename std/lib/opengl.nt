module std.lib.opengl;

platform(!*-mingw32) {
  // only opengl 1.2 is supported on windows: thus, must only enable this under linux
  pragma(define, "GL_GLEXT_PROTOTYPES");
}
// depends on GLsizei, which is defined in gl.h - yuck
pragma(include_prepend, "GL/gl.h < GL/glext.h");
public import c.GL.gl;
public import c.GL.glu;
public import c.GL.glext;
public import std.lib.opengl.rgbcolor;

platform(i686-mingw32) {
  pragma(lib, "opengl32");
  pragma(lib, "glu32");
  extern(Windows) void* wglGetProcAddress(char*);
  template lookupFun(T) {
    _markStdCall T lookupFun(char* c) { return _markStdCall T:wglGetProcAddress(c); }
  }
  alias glGenBuffers = *lookupFun!void function(GLsizei, GLuint*) "glGenBuffers";
  alias glBindBuffer = *lookupFun!void function(GLenum, GLuint) "glBindBuffer";
  alias glBufferData = *lookupFun!void function(GLenum, GLsizeiptr, void*, GLenum) "glBufferData";
}

platform(default) {
  public import c.GL.glx;
  pragma(lib, "GL");
  pragma(lib, "GLU");
  extern(C) void* glXGetProcAddress(char*);
  template lookupFun(T) {
    T lookupFun(char* c) { return T:glXGetProcAddress(c); }
  }
}

defmode GL "prefix GL_ prefix gl suffix _ARB suffix ARB";

context Triangles {
  alias onUsing = glBegin GL_TRIANGLES;
  alias onExit = glEnd;
}

context Quads {
  alias onUsing = glBegin GL_QUADS;
  alias onExit = glEnd;
}

context QuadStrip {
  alias onUsing = glBegin GL_QUAD_STRIP;
  alias onExit = glEnd;
}

context glMatrix {
  void pushAll() using mode GL {
    GetIntegerv(MATRIX_MODE, &int mode);
    onSuccess MatrixMode mode;
    MatrixMode PROJECTION; PushMatrix;
    MatrixMode MODELVIEW;  PushMatrix;
    MatrixMode TEXTURE;    PushMatrix;
  }
  void popAll() using mode GL {
    GetIntegerv(MATRIX_MODE, &int mode);
    onSuccess MatrixMode mode;
    MatrixMode PROJECTION; PopMatrix;
    MatrixMode MODELVIEW;  PopMatrix;
    MatrixMode TEXTURE;    PopMatrix;
  }
  alias onUsing = pushAll();
  alias onExit  = popAll ();
}

template glWithCap(alias Cap) {
  GLboolean[auto~] capstack;
  context glWithCap {
    void onUsing() { auto state = glIsEnabled Cap; if (!state) glEnable Cap; capstack ~= state; }
    void onExit() { auto prev = capstack.popEnd(); if (!prev) glDisable Cap; }
  }
}

template glWithoutCap(alias Cap) {
  GLboolean[auto~] capstack;
  context glWithoutCap {
    void onUsing() { auto state = glIsEnabled Cap; if (state) glDisable Cap; capstack ~= state; }
    void onExit() { auto prev = capstack.popEnd(); if (prev) glEnable Cap; }
  }
}

class OpenGLError : Error {
  void init(string s) { super.init "OpenGLError: $s"; }
}

void gl-check() {
  using prefix GL_ {
    import std.macros.switchover;
    auto err = glGetError();
    switch GLenum i over i == err {
      case NO_ERROR: return;
      case INVALID_ENUM: raise new OpenGLError "invalid enum";
      case INVALID_VALUE: raise new OpenGLError "invalid value";
      case INVALID_OPERATION: raise new OpenGLError "invalid operation";
      case STACK_OVERFLOW: raise new OpenGLError "stack overflow";
      case STACK_UNDERFLOW: raise new OpenGLError "stack underflow";
      case OUT_OF_MEMORY: raise new OpenGLError "out of memory";
    }
    raise new OpenGLError "Unknown OpenGL error $err";
  }
}
