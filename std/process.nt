module std.process;

import c.poll, c.stdlib, c.unistd;
import std.string;

class ReadbackError : Error {
  void init(string s) super.init "ReadbackError: $s";
}

class ReadbackStream : Iterator!string {
  int x 2 hdl_sysward, hdl_selfward;
  bool hup, done; int fdslength;
  Iterator!string input; string inbuffer;
  char x 128 buf;
  void init(string cmd, Iterator!string input) {
    pipe hdl_sysward; // self -> system()
    pipe hdl_selfward; // system() -> self
    system toStringz "exec $(hdl_sysward[1])>&-; exec $(hdl_selfward[0])>&-; <&$(hdl_sysward[0]) $cmd >&$(hdl_selfward[1]) &";
    close hdl_sysward[0]; // read side
    close hdl_selfward[1]; // write side
    fdslength = 2;
    this.input = input;
  }
  bool advance() {
    while !done { // while we still have data to write .. 
      pollfd x 2 fds;
      fds[0].(fd, events) = (hdl_selfward[0], POLLIN);
      fds[1].(fd, events) = (hdl_sysward [1], POLLOUT);
      auto hits = poll(fds.ptr, fdslength, -1);
      // don't quit yet - there may still be data to be read!
      if (fds[0].revents & POLLHUP) { hup = true; }
      bool handleRead() {
        auto size = read buf.(hdl_selfward[0], ptr, length);
        if (size > 0) {
          value = buf[0 .. size];
          return true;
        }
        done = true;
        return false;
      }
      void handleWrite() {
        if (!inbuffer.length) {
          if (!input || !input.advance()) {
            // no more data to write
            close hdl_sysward[1];
            fdslength = 1;
            return;
          }
          assert(input.value.length != 0, "input claimed to advance but data is null");
          inbuffer = input.value;
        }
        auto res = write inbuffer.(hdl_sysward[1], ptr, length);
        if res < 0
          raise-error new ReadbackError "Writing to stream failed! ";
        inbuffer = inbuffer[res .. $];
      }
      bool active;
      if (fdslength == 2 && fds[1].revents & POLLOUT) { handleWrite; active = true; }
      if (fds[0].revents & POLLIN) { if (handleRead()) return true; active = true; }
      // basically done.
      if (!active && hup) return false;
    }
    return false;
  }
}

ReadbackStream readback(string cmd, Iterator!string data = null) {
  return new ReadbackStream (cmd, data);
}

import std.util;
ReadbackStream readback(string cmd, string data) return readback(cmd, Iterator!string: iterOnce data);
