/*Title: std.file
File I/O*/
module std.file;

import c.dirent, c.stdio, c.fcntl, c.unistd, c.errno, c.stdlib, c.sys.stat;

class ErrnoError : Error {
  int errno;
  string err;
  void init() {
    errno = .errno;
  }
  void init(string e) {
    init();
    err = e;
  }
  string toString() { return "ErrnoError $(err): $(CToString strerror(errno)) ($errno)"; }
}

/*Template: readfile
  Returns an iterator over byte[] that yields incremental chunks from a file.
*/
template readfile(T) {
  class reader : Iterator!byte[] {
    int fd;
    byte x 256  buf;
    void close() { .close(fd); }
    bool advance() {
      auto size = read(fd, buf.ptr, buf.length);
      if size <= 0 { close; return false; }
      value = buf[0 .. size];
      return true;
    }
  }
  reader readfile(T t) {
    auto res = new reader;
    res.fd = t;
    return res;
  }
}

alias C_open = open;

import std.string;

platform(default) {
  alias read-mode = O_RDONLY, tweak-mode = 0;
}

platform(i686-mingw32) {
  alias read-mode = O_RDONLY | O_BINARY; // FUCK YOU SO HARD MICROSOFT WINDOWS.
  alias tweak-mode = O_BINARY;
}

platform(arm*) {
  alias read-mode = O_RDONLY, tweak-mode = 0;
}

/*
  Function: open
  Wrapper around C's open()
*/
int open(string file, int read-mode = read-mode, mode_t perms = 0) {
  auto ptr = toStringz(file);
  onExit mem.free(ptr);
  return C_open(ptr, read-mode | tweak-mode, perms);
}

/*Function: readAll
  Completely reads a file from the drive. */
ubyte[] readAll(string file) { return join readfile open file; } // God I love this line so hard.

class WriterError : Error {
  void init() { super.init "WriterError"; }
}

class writer {
  int hdl;
  void step(byte[] data) {
    while data.length {
      auto res = write(hdl, data.ptr, data.length);
      if res == -1 { perror "While writing $(data.length) bytes".toStringz(); raise (new WriterError); }
      data = data[res .. $];
    }
  }
  void close() { .close hdl; }
}

/*Function: writefile
Returns a delegate that, when called, will write its parameter to a handle.

Parameters:
  _hdl - a file handle
*/
void delegate(byte[]) writefile(int _hdl) using new writer {
  hdl = _hdl;
  return &step;
}

/*Function: writeAll
Writes data to a file.

Parameters:
  string file - the filename
  byte[] data - the data to write*/
void writeAll(string file, byte[] data) using new writer {
  mode_t perms;
  platform(i686-mingw32) {
    perms = S_IREAD | S_IWRITE;
  }
  platform(!i686-mingw32) {
    perms = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
  }
  hdl = file.open (O_RDWR | O_CREAT, perms);
  step data;
  close;
}

alias c_getcwd = getcwd;

/*Function: getcwd
Wraps around the C getcwd function*/
string getcwd() {
  auto buffer = new char[] 128;
  while true {
    if (c_getcwd(buffer.ptr, buffer.length)) {
      return buffer[0 .. strlen buffer.ptr];
    }
    auto oldlen = buffer.length;
    buffer.free;
    buffer = new char[] (oldlen * 2);
  }
}

/*Function: basedir
Returns the directory component of its argument*/
string basedir(string file) {
  if file.endsWith "/" return file;
  while file.length && file[$-1] != "/"[0]
    file = file[0 .. $-1];
  return file;
}

// in path1, access path2
/*Function: sub
Given two paths, returns the second path as seen from the first path. */
string sub(string path1, path2) {
  if path2.startsWith "/" return path2;
  if path1.endsWith "/" return path1 ~ path2;
  return path1 ~ "/" ~ path2;
}

time_t accessed(string file) {
  int fd = open file;
  if (fd == -1) raise new ErrnoError;
  fstat(fd, &stat s);
  close fd;
  platform(i686-mingw32) {
    return s.st_atime;
  }
  platform(!i686-mingw32) {
    return s.st_atim.tv_sec;
  }
}

time_t modified(string file) {
  int fd = open file;
  if (fd == -1) raise new ErrnoError;
  fstat(fd, &stat s);
  close fd;
  platform(i686-mingw32) {
    return s.st_mtime;
  }
  platform(!i686-mingw32) {
    return s.st_mtim.tv_sec;
  }
}

time_t statuschanged(string file) {
  int fd = open file;
  if (fd == -1) raise new ErrnoError;
  fstat(fd, &stat s);
  close fd;
  platform(i686-mingw32) {
    return s.st_ctime;
  }
  platform(!i686-mingw32) {
    return s.st_ctim.tv_sec;
  }
}

// TODO: win32
platform(!i686-mingw32) {
  alias C_realpath = realpath;
  reassign string realpath(string path) {
    return CToString C_realpath(toStringz path, null);
  }
}

/*
  Function: exists
  Returns whether a file exists.
*/
bool exists(string file) {
  return access(toStringz file, F_OK) != -1;
}

extern(C) int stat(char* path, void* buf);
RenameIdentifier stat cstdlib-stat;

/*
  Function: isDir
  Returns true if the argument is a directory
*/
bool isDir(string s) {
  cstdlib-stat(toStringz s, &stat buf);
  return !!(buf.st_mode & S_IFDIR);
}

extern(C) char* strerror(int errnum);
/*
  Function: listDirectory
  Lists a directory's contents and returns an array of file/directory names.
*/
platform(!i686-mingw32) {
  string[] listDirectory(string path) {
    string[auto~] ret;
    
    auto dp = opendir toStringz path;
    if !dp {
      auto err = new Error CToString strerror errno;
      raise err;
    }
    
    do {
      auto entry = readdir dp;
    } while entry {
      ret ~= CToString entry.d_name;
    }
    
    return ret[];
  }
}

