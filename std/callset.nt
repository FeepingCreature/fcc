module std.callset;

/**
  Usage:
    CallSet!void foo;
    ...
    foo.add \{};
    foo.call();
**/

template CallSet(T) {
  static if (types-equal (T, void)) {
    alias DG = void delegate();
  } else {
    alias DG = void delegate(T);
  }
  alias callset-str = `
    template CallSet(U) {
      struct CallSet {
        DG[auto~] dgs;
        void call(%ARG%) {
          for auto dg <- dgs dg?(%ARGVAL%);
        }
        alias implicit-cast = &call;
        void add(DG dg) {
          for ref dg2 <- dgs
            if (!dg2) { dg2 = dg; return; }
          dgs ~= dg;
        }
        void remove(DG dg) {
          for ref dg2 <- dgs
            if ((void*,void*):dg == (void*,void*):dg2) dg2 = null;
        }
      }
    }
  `;
  mixin(callset-str.replace("CallSet","CallSetA").replace("%ARG%","").replace("%ARGVAL%", ""));
  mixin(callset-str.replace("CallSet","CallSetB").replace("%ARG%","T t").replace("%ARGVAL%", "t"));
  static if (types-equal(T, void)) {
    alias CallSet = CallSetA!(int);
  } else {
    alias CallSet = CallSetB!(int);
  }
}
