/*Title: std.socket
Wraps the BSD Sockets API*/
module std.socket;

import std.string, std.async, c.unistd, c.errno;
platform(*-mingw32) {
  pragma(define, "_WIN32_WINNT=0x0501"); // target xp
  import c.winsock2, c.ws2tcpip;
  pragma(lib, "ws2_32");
  void init() { WSAStartup(2<<8 | 2, &WSADATA bogus); }
}
platform(default) {
  import c.sys.socket, c.netdb, c.string;
}

/*Class: Address
An internet address*/
class Address {
  (sockaddr*, int) getAddrHandle() { raise new Error "getAddrHandle not implemented"; return (sockaddr*:null, 0); }
  Address dup() { raise new Error "dup not implemented"; }
}

/*Class: TcpAddress
A TCP address*/
class TcpAddress : Address {
  sockaddr_in saddr;
  (sockaddr*, int) getAddrHandle() {
    return (sockaddr*:&saddr, size-of sockaddr_in);
  }
  Address dup() using new TcpAddress {
    that.saddr = this.saddr;
    return that;
  }
  void init() { }
  /*Function: init
  Create a TCP address from host name and port*/
  void init(string dns, short port) {
    using saddr {
      addrinfo* addr;
      getaddrinfo(toStringz dns, null, null, &addr);
      if (!addr) {
        fail "Could not resolve $dns";
      }
      *sockaddr*:&saddr = *addr.ai_addr;
      sin_family = AF_INET;
      sin_port = htons(port);
    }
  }
}

class SocketError : Error {
  void init(int i) { super.init("socket operation failed: $i"); }
  void init(string s) { super.init "socket operation failed: $s"; }
}

/*Class: Socket
A BSD Socket*/
class Socket : AsyncHandle {
  int sockfd;
  override int[] getFds() { return (&sockfd)[0..1]; }
  Address boundAddr;
  /*Function: close*/
  void close() {
    auto err = c.unistd.close(sockfd);
    if (err == -1) {
      raise new Error "While closing socket: $(CToString strerror errno)";
    }
  }
  void free() { boundAddr?.free; super.free; }
  /*Function: init*/
  void init(bool bare = false) {
    if (!bare) {
      sockfd = socket (AF_INET, SOCK_STREAM, 0);
      linger(true, 30); // default: linger 30s
    }
  }
  /*Function: init*/
  void init(string domain, short port) {
    init;
    scope ta = new TcpAddress(domain, port);
    open ta;
  }
  (bool got, float value) myTimeout;
  /*Function: setTimeout
  Sets a timeout for socket read/write operations (in seconds)*/
  void setTimeout(float t) {
    // DO NOT USE SETSOCKOPT HERE !!!!!!!!!
    myTimeout = (true, t);
  }
  void delegate(AsyncBlockMode mode) asyncfun;
  /*Function: setAsyncFun
  Implements AsyncHandle.
  If set, recv/send will retry as long as they cannot send
  or receive any data. However, they will also alternatingly call the
  yield() function passed as a parameter.*/
  override void setAsyncFun(void delegate(AsyncBlockMode mode) yield) {
    asyncfun = yield;
    
    import c.fcntl;
    auto flags = sockfd.fcntl (F_GETFL);
    if (yield) {
      flags |= O_NONBLOCK;
    } else {
      flags &= int: Â¬O_NONBLOCK;
    }
    sockfd.fcntl(F_SETFL, flags);
  }
  /*Function: reuse
  Marks the socket as reusable*/
  void reuse(bool b) {
    platform(*-mingw32) {
      setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, char*:&b, size-of bool);
    }
    platform(default) {
      setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &b, size-of bool);
    }
  }
  /*Function: linger
  On close(), linger up to t seconds or until all data has been transmitted.*/
  void linger(bool dolinger, int t) {
    c.sys.socket.linger l;
    l.l_onoff = dolinger;
    l.l_linger = t;
    setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &l, size-of c.sys.socket.linger);
  }
  // alias isOpen = sockfd;
  /*Function: open*/
  void open(TcpAddress ta) {
    platform(default) {
      auto res = c.sys.socket.connect (sockfd, sockaddr*:&ta.saddr, size-of type-of ta.saddr);
    }
    platform(*-mingw32) {
      auto res = c.winsock2.connect (sockfd, sockaddr*:&ta.saddr, size-of type-of ta.saddr);
    }
  }
  /*Function: recv
  Fills the argument with data from the socket, returning the number of bytes received. */
  int recv(ubyte[] buf) {
    if (myTimeout.got) {
      SelectSet ss;
      ss.add(this, AsyncBlockMode.Reading);
      ss.select(int:(myTimeout.value*1_000_000));
      if (!ss.isReady(this, AsyncBlockMode.Reading))
        raise new SocketError "read timed out";
    }
    while (true) {
      platform(default) {
        auto res = .recv(sockfd, buf.ptr, buf.length, 0);
      }
      platform(*-mingw32) {
        auto res = .recv(sockfd, char*:buf.ptr, buf.length, 0);
      }
      if (asyncfun && res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
        // yield? in any case, retry
        asyncfun?(AsyncBlockMode.Reading);
        continue;
      }
      if (res <= 0) {
        close;
      }
      return res;
    }
  }
  /*Function: send
  Sends some of the argument, returning the number of bytes sent. */
  int send(ubyte[] buf) {
    while (true) {
      platform(default) {
        auto res = .send(sockfd, buf.ptr, buf.length, 0);
      }
      platform(*-mingw32) {
        auto res = .send(sockfd, char*:buf.ptr, buf.length, 0);
      }
      if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
        // yield? in any case, retry
        asyncfun?(AsyncBlockMode.Writing);
        continue;
      }
      if (res <= 0) {
        close;
      }
      return res;
    }
  }
  /*Function: sendAll
  Sends all of the argument*/
  void sendAll(ubyte[] buf) {
    while buf.length {
      auto res = send buf;
      if (res <= 0) return;
      buf = buf[res .. $];
    }
  }
  /*Function: bind
  Bind the socket to an address*/
  void bind(Address addr) {
    boundAddr = addr;
    auto err = .bind(sockfd, addr.getAddrHandle());
    if (err == -1)
      raise new Error "While binding to $addr: $(CToString strerror errno)";
  }
  /*Function: listen
  Listen for incoming connections */
  void listen(int backlog = 4) {
    auto err = .listen(sockfd, backlog);
    if (err == -1)
      raise new Error "While trying to listen: $(CToString strerror errno)";
  }
  /*Function: accept
  Once incoming connections occur, return a socket for them*/
  Socket accept() {
    using new Socket (=>bare) {
      that.boundAddr = this.boundAddr.dup;
      auto hdl = that.boundAddr.getAddrHandle();
      int gotLength = hdl[1];
      auto fam = hdl[0].sa_family;
      while (true) {
        auto res = .accept(this.sockfd, hdl[0], &gotLength);
        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
          this.asyncfun?(AsyncBlockMode.Reading);
          continue;
        }
        if (res == -1) {
          raise new Error "While accepting connections on $(this.sockfd): $(CToString strerror errno)";
        }
        if (hdl[0].sa_family != fam || gotLength > hdl[1])
          raise new Error ("Accepted socket address was of incompatible type to listening socket: "
            ~"$(hdl[0].sa_family) ($gotLength), but expected $(fam) ($(hdl[1]))! ");
        that.sockfd = res;
        return that;
      }
    }
  }
}

/*Section: std.socket*/
/*Function: connect
Open a socket for the given domain/port*/
Socket connect(string domain, short port) using new Socket {
  that.open new TcpAddress(domain, port);
  return that;
}

class sockreader : Iterator!ubyte[] {
  Socket sock;
  bool done;
  ubyte x 4096  buf;
  void init(Socket s) sock = s;
  bool advance() {
    auto size = sock.recv buf[];
    if size == -1 raise new SocketError errno;
    if size == 0 return false;
    value = buf[0 .. size];
    return true;
  }
}

sockreader readsocket(Socket s) return new sockreader s;
